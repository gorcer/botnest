{
    "sourceFile": "src/bot/bot.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 19,
            "patches": [
                {
                    "date": 1691542093089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1691542125053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -231,10 +231,10 @@\n \t\t\t\t\tfee: feeInCurrency2Cost,\n \t\t\t\t\taccountId\n \t\t\t\t});\n \n-\t\t\t\tawait this.balance.income(accountId, order.currency1, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, extOrder.cost);\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n \t\t\t\tif (feeCost && feeCurrency) {\n \t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, feeCost);\n \t\t\t\t}\n \n"
                },
                {
                    "date": 1691542146777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -231,12 +231,12 @@\n \t\t\t\t\tfee: feeInCurrency2Cost,\n \t\t\t\t\taccountId\n \t\t\t\t});\n \n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY extOrder.amount);\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n \t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n \t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, feeCost);\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n \t\t\t\t}\n \n \t\t\t\tthis.log.info(\n \t\t\t\t\t\"New order\",\n"
                },
                {
                    "date": 1691542167016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,355 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate accountConfig(accountId): Config {\n+\t\treturn this.accounts.getConfig(accountId);\n+\t}\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n+\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst amount1: number = this.checkLimits(rate, config.orderAmount);\n+\t\tconst amount2: number = multiply(rate, amount1);\n+\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n+\n+\t\tif (compareTo(balance2, amount2) > 0) {\n+\n+\t\t\treturn await this.createBuyOrder(\n+\t\t\t\taccountId,\n+\t\t\t\tconfig.currency1,\n+\t\t\t\tconfig.currency2,\n+\t\t\t\trate,\n+\t\t\t\tamount1\n+\t\t\t);\n+\n+\t\t} else {\n+\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n+\t\t\tawait sleep(60);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * \n+\t * @param price Fix amount to limits\n+\t * @param amount1 \n+\t * @returns \n+\t */\n+\tprivate checkLimits(price: number, amount1: number) {\n+\t\tif (compareTo(amount1, this.minAmount) < 0)\n+\t\t\tamount1 = this.minAmount;\n+\n+\t\tconst amount2 = multiply(price, amount1);\n+\t\tif (compareTo(amount2, this.minCost) < 0) {\n+\t\t\tamount1 = divide(this.minCost * 1.1, price, 6);\n+\t\t}\n+\n+\t\treturn amount1;\n+\t}\n+\n+\n+\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691542181945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,355 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate accountConfig(accountId): Config {\n+\t\treturn this.accounts.getConfig(accountId);\n+\t}\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n+\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst amount1: number = this.checkLimits(rate, config.orderAmount);\n+\t\tconst amount2: number = multiply(rate, amount1);\n+\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n+\n+\t\tif (compareTo(balance2, amount2) > 0) {\n+\n+\t\t\treturn await this.createBuyOrder(\n+\t\t\t\taccountId,\n+\t\t\t\tconfig.currency1,\n+\t\t\t\tconfig.currency2,\n+\t\t\t\trate,\n+\t\t\t\tamount1\n+\t\t\t);\n+\n+\t\t} else {\n+\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n+\t\t\tawait sleep(60);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * \n+\t * @param price Fix amount to limits\n+\t * @param amount1 \n+\t * @returns \n+\t */\n+\tprivate checkLimits(price: number, amount1: number) {\n+\t\tif (compareTo(amount1, this.minAmount) < 0)\n+\t\t\tamount1 = this.minAmount;\n+\n+\t\tconst amount2 = multiply(price, amount1);\n+\t\tif (compareTo(amount2, this.minCost) < 0) {\n+\t\t\tamount1 = divide(this.minCost * 1.1, price, 6);\n+\t\t}\n+\n+\t\treturn amount1;\n+\t}\n+\n+\n+\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691542284788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -351,715 +351,5 @@\n \t\tthis.log.info('Ok');\n \t}\n \n \n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n-\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst amount1: number = this.checkLimits(rate, config.orderAmount);\n-\t\tconst amount2: number = multiply(rate, amount1);\n-\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n-\n-\t\tif (compareTo(balance2, amount2) > 0) {\n-\n-\t\t\treturn await this.createBuyOrder(\n-\t\t\t\taccountId,\n-\t\t\t\tconfig.currency1,\n-\t\t\t\tconfig.currency2,\n-\t\t\t\trate,\n-\t\t\t\tamount1\n-\t\t\t);\n-\n-\t\t} else {\n-\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n-\t\t\tawait sleep(60);\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * \n-\t * @param price Fix amount to limits\n-\t * @param amount1 \n-\t * @returns \n-\t */\n-\tprivate checkLimits(price: number, amount1: number) {\n-\t\tif (compareTo(amount1, this.minAmount) < 0)\n-\t\t\tamount1 = this.minAmount;\n-\n-\t\tconst amount2 = multiply(price, amount1);\n-\t\tif (compareTo(amount2, this.minCost) < 0) {\n-\t\t\tamount1 = divide(this.minCost * 1.1, price, 6);\n-\t\t}\n-\n-\t\treturn amount1;\n-\t}\n-\n-\n-\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n-\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst amount1: number = this.checkLimits(rate, config.orderAmount);\n-\t\tconst amount2: number = multiply(rate, amount1);\n-\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n-\n-\t\tif (compareTo(balance2, amount2) > 0) {\n-\n-\t\t\treturn await this.createBuyOrder(\n-\t\t\t\taccountId,\n-\t\t\t\tconfig.currency1,\n-\t\t\t\tconfig.currency2,\n-\t\t\t\trate,\n-\t\t\t\tamount1\n-\t\t\t);\n-\n-\t\t} else {\n-\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n-\t\t\tawait sleep(60);\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * \n-\t * @param price Fix amount to limits\n-\t * @param amount1 \n-\t * @returns \n-\t */\n-\tprivate checkLimits(price: number, amount1: number) {\n-\t\tif (compareTo(amount1, this.minAmount) < 0)\n-\t\t\tamount1 = this.minAmount;\n-\n-\t\tconst amount2 = multiply(price, amount1);\n-\t\tif (compareTo(amount2, this.minCost) < 0) {\n-\t\t\tamount1 = divide(this.minCost * 1.1, price, 6);\n-\t\t}\n-\n-\t\treturn amount1;\n-\t}\n-\n-\n-\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691543667698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,354 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate accountConfig(accountId): Config {\n+\t\treturn this.accounts.getConfig(accountId);\n+\t}\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n+\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst amount1: number = this.checkLimits(rate, config.orderAmount);\n+\t\tconst amount2: number = multiply(rate, amount1);\n+\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n+\n+\t\tif (compareTo(balance2, amount2) > 0) {\n+\n+\t\t\treturn await this.createBuyOrder(\n+\t\t\t\taccountId,\n+\t\t\t\tconfig.currency1,\n+\t\t\t\tconfig.currency2,\n+\t\t\t\trate,\n+\t\t\t\tamount1\n+\t\t\t);\n+\n+\t\t} else {\n+\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n+\t\t\tawait sleep(60);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * \n+\t * @param price Fix amount to limits\n+\t * @param amount1 \n+\t * @returns \n+\t */\n+\tprivate checkLimits(price: number, amount1: number) {\n+\t\tif (compareTo(amount1, this.minAmount) < 0)\n+\t\t\tamount1 = this.minAmount;\n+\n+\t\tconst amount2 = multiply(price, amount1);\n+\t\tif (compareTo(amount2, this.minCost) < 0) {\n+\t\t\tamount1 = divide(this.minCost * 1.1, price, 6);\n+\t\t}\n+\n+\t\treturn amount1;\n+\t}\n+\n+\n+\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691543838316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,8 +126,9 @@\n \t\t\treturn false;\n \n \t\t});\n \t}\n+\t\n \tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n \n \t\tconst config = this.accountConfig(accountId);\n \t\tconst amount1: number = this.checkLimits(rate, config.orderAmount);\n@@ -350,360 +351,5 @@\n \t\tthis.log.info('Ok');\n \t}\n \n \n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n-\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst amount1: number = this.checkLimits(rate, config.orderAmount);\n-\t\tconst amount2: number = multiply(rate, amount1);\n-\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n-\n-\t\tif (compareTo(balance2, amount2) > 0) {\n-\n-\t\t\treturn await this.createBuyOrder(\n-\t\t\t\taccountId,\n-\t\t\t\tconfig.currency1,\n-\t\t\t\tconfig.currency2,\n-\t\t\t\trate,\n-\t\t\t\tamount1\n-\t\t\t);\n-\n-\t\t} else {\n-\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n-\t\t\tawait sleep(60);\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * \n-\t * @param price Fix amount to limits\n-\t * @param amount1 \n-\t * @returns \n-\t */\n-\tprivate checkLimits(price: number, amount1: number) {\n-\t\tif (compareTo(amount1, this.minAmount) < 0)\n-\t\t\tamount1 = this.minAmount;\n-\n-\t\tconst amount2 = multiply(price, amount1);\n-\t\tif (compareTo(amount2, this.minCost) < 0) {\n-\t\t\tamount1 = divide(this.minCost * 1.1, price, 6);\n-\t\t}\n-\n-\t\treturn amount1;\n-\t}\n-\n-\n-\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691551562729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,338 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate accountConfig(accountId): Config {\n+\t\treturn this.accounts.getConfig(accountId);\n+\t}\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\n+\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n+\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst amount1: number = checkLimits(rate, config.orderAmount);\n+\t\tconst amount2: number = multiply(rate, amount1);\n+\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n+\n+\t\tif (compareTo(balance2, amount2) > 0) {\n+\n+\t\t\treturn await this.createBuyOrder(\n+\t\t\t\taccountId,\n+\t\t\t\tconfig.currency1,\n+\t\t\t\tconfig.currency2,\n+\t\t\t\trate,\n+\t\t\t\tamount1\n+\t\t\t);\n+\n+\t\t} else {\n+\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n+\t\t\tawait sleep(60);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\n+\n+\n+\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691552203210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,338 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate accountConfig(accountId): Config {\n+\t\treturn this.accounts.getConfig(accountId);\n+\t}\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\n+\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n+\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst amount1: number = checkLimits(this.minAmount, this.minCost, rate, config.orderAmount);\n+\t\tconst amount2: number = multiply(rate, amount1);\n+\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n+\n+\t\tif (compareTo(balance2, amount2) > 0) {\n+\n+\t\t\treturn await this.createBuyOrder(\n+\t\t\t\taccountId,\n+\t\t\t\tconfig.currency1,\n+\t\t\t\tconfig.currency2,\n+\t\t\t\trate,\n+\t\t\t\tamount1\n+\t\t\t);\n+\n+\t\t} else {\n+\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n+\t\t\tawait sleep(60);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\n+\n+\n+\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554596162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,338 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate accountConfig(accountId): Config {\n+\t\treturn this.accounts.getConfig(accountId);\n+\t}\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\n+\t// public async tryToBuy(accountId: number, rate: number): Promise<any> {\n+\n+\t// \tconst config = this.accountConfig(accountId);\n+\t// \tconst amount1: number = checkLimits(this.minAmount, this.minCost, rate, config.orderAmount);\n+\t// \tconst amount2: number = multiply(rate, amount1);\n+\t// \tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n+\n+\t// \tif (compareTo(balance2, amount2) > 0) {\n+\n+\t// \t\treturn await this.createBuyOrder(\n+\t// \t\t\taccountId,\n+\t// \t\t\tconfig.currency1,\n+\t// \t\t\tconfig.currency2,\n+\t// \t\t\trate,\n+\t// \t\t\tamount1\n+\t// \t\t);\n+\n+\t// \t} else {\n+\t// \t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n+\t// \t\tawait sleep(60);\n+\t// \t\treturn false;\n+\t// \t}\n+\t// }\n+\n+\n+\n+\n+\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691558705010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,312 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate accountConfig(accountId): Config {\n+\t\treturn this.accounts.getConfig(accountId);\n+\t}\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\n+\n+\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691558712133,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,288 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate accountConfig(accountId): Config {\n+\t\treturn this.accounts.getConfig(accountId);\n+\t}\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691558791756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,289 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate accountConfig(accountId): Config {\n+\t\treturn this.accounts.getConfig(accountId);\n+\t}\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\n+\t\tconst accountId = order.accountId;\n+\t\tconst config = this.accountConfig(accountId);\n+\t\tconst api = this.api(order.accountId);\n+\t\tconst pair = order.currency1 + '/' + order.currency2;\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691558802549,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,11 +211,9 @@\n \n \n \tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n \n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n+\t\tlet closeOrder: Order;\t\t\n \t\tconst api = this.api(order.accountId);\n \t\tconst pair = order.currency1 + '/' + order.currency2;\n \t\tlet extOrder;\n \n@@ -285,1974 +283,5 @@\n \t\tthis.log.info('Ok');\n \t}\n \n \n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\n-\n-\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\n-\t// public async tryToBuy(accountId: number, rate: number): Promise<any> {\n-\n-\t// \tconst config = this.accountConfig(accountId);\n-\t// \tconst amount1: number = checkLimits(this.minAmount, this.minCost, rate, config.orderAmount);\n-\t// \tconst amount2: number = multiply(rate, amount1);\n-\t// \tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n-\n-\t// \tif (compareTo(balance2, amount2) > 0) {\n-\n-\t// \t\treturn await this.createBuyOrder(\n-\t// \t\t\taccountId,\n-\t// \t\t\tconfig.currency1,\n-\t// \t\t\tconfig.currency2,\n-\t// \t\t\trate,\n-\t// \t\t\tamount1\n-\t// \t\t);\n-\n-\t// \t} else {\n-\t// \t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n-\t// \t\tawait sleep(60);\n-\t// \t\treturn false;\n-\t// \t}\n-\t// }\n-\n-\n-\n-\n-\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\n-\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n-\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst amount1: number = checkLimits(this.minAmount, this.minCost, rate, config.orderAmount);\n-\t\tconst amount2: number = multiply(rate, amount1);\n-\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n-\n-\t\tif (compareTo(balance2, amount2) > 0) {\n-\n-\t\t\treturn await this.createBuyOrder(\n-\t\t\t\taccountId,\n-\t\t\t\tconfig.currency1,\n-\t\t\t\tconfig.currency2,\n-\t\t\t\trate,\n-\t\t\t\tamount1\n-\t\t\t);\n-\n-\t\t} else {\n-\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n-\t\t\tawait sleep(60);\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\n-\n-\n-\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\n-\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n-\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst amount1: number = checkLimits(rate, config.orderAmount);\n-\t\tconst amount2: number = multiply(rate, amount1);\n-\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n-\n-\t\tif (compareTo(balance2, amount2) > 0) {\n-\n-\t\t\treturn await this.createBuyOrder(\n-\t\t\t\taccountId,\n-\t\t\t\tconfig.currency1,\n-\t\t\t\tconfig.currency2,\n-\t\t\t\trate,\n-\t\t\t\tamount1\n-\t\t\t);\n-\n-\t\t} else {\n-\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n-\t\t\tawait sleep(60);\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\n-\n-\n-\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\t\n-\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n-\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst amount1: number = this.checkLimits(rate, config.orderAmount);\n-\t\tconst amount2: number = multiply(rate, amount1);\n-\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n-\n-\t\tif (compareTo(balance2, amount2) > 0) {\n-\n-\t\t\treturn await this.createBuyOrder(\n-\t\t\t\taccountId,\n-\t\t\t\tconfig.currency1,\n-\t\t\t\tconfig.currency2,\n-\t\t\t\trate,\n-\t\t\t\tamount1\n-\t\t\t);\n-\n-\t\t} else {\n-\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n-\t\t\tawait sleep(60);\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * \n-\t * @param price Fix amount to limits\n-\t * @param amount1 \n-\t * @returns \n-\t */\n-\tprivate checkLimits(price: number, amount1: number) {\n-\t\tif (compareTo(amount1, this.minAmount) < 0)\n-\t\t\tamount1 = this.minAmount;\n-\n-\t\tconst amount2 = multiply(price, amount1);\n-\t\tif (compareTo(amount2, this.minCost) < 0) {\n-\t\t\tamount1 = divide(this.minCost * 1.1, price, 6);\n-\t\t}\n-\n-\t\treturn amount1;\n-\t}\n-\n-\n-\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691558837093,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,282 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\n+\t\tconst accountId = order.accountId;\t\t\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\t\t\n+\t\tconst api = this.api(order.accountId);\n+\t\tconst pair = order.currency1 + '/' + order.currency2;\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691558845078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,281 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+interface Config {\n+\tpair: string,\n+\torderAmount: number,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\torderProbability: number,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+\n+}\n+\n+@Injectable()\n+export class BotService {\n+\n+\n+\tprivate minAmount: number;\n+\tprivate minCost: number;\n+\tprivate config: any = {};\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\tsetConfig(config) {\n+\t\tthis.config = config;\n+\t}\n+\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\t\t\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\t\t\n+\t\tconst api = this.api(order.accountId);\n+\t\tconst pair = order.currency1 + '/' + order.currency2;\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\n+\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691558961649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,11 +31,8 @@\n @Injectable()\n export class BotService {\n \n \n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n \n \tconstructor(\n \n \t\tpublic balance: BalanceService,\n@@ -270,581 +267,11 @@\n \tasync syncData(accountId: number) {\n \n \t\tthis.log.info('Sync data ....');\n \n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\t\t\n \n \t\tthis.log.info('Ok');\n \t}\n \n \n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\t\t\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\t\t\n-\t\tconst api = this.api(order.accountId);\n-\t\tconst pair = order.currency1 + '/' + order.currency2;\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\tprivate minAmount: number;\n-\tprivate minCost: number;\n-\tprivate config: any = {};\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate accountConfig(accountId): Config {\n-\t\treturn this.accounts.getConfig(accountId);\n-\t}\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\n-\t\tconst accountId = order.accountId;\n-\t\tconst config = this.accountConfig(accountId);\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\t\t\n-\t\tconst api = this.api(order.accountId);\n-\t\tconst pair = order.currency1 + '/' + order.currency2;\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\n-\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691558979255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,256 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n+import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { OperationType } from \"../balance/entities/balanceLog.entity\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+@Injectable()\n+export class BotService {\n+\n+\tconstructor(\n+\n+\t\tpublic balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate log: FileLogService,\n+\t\tpublic publicApi: PublicApiService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate pairs: PairService\n+\n+\t) { }\n+\n+\n+\n+\tprivate api(accountId): ApiService {\n+\t\treturn this.accounts.getApiForAccount(accountId);\n+\t}\n+\n+\n+\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n+\t\t\n+\t\tconst api = this.api(order.accountId);\n+\n+\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\tthis.log.info('Check close order', order.extOrderId);\n+\n+\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n+\t\t\t\treturn;\n+\n+\t\t\tif (!extOrder)\n+\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n+\n+\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n+\n+\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n+\n+\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\t// Fill parent buy-order\n+\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n+\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n+\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n+\t\t\t\t};\n+\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n+\n+\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n+\t\t\t\t\tupdateOrderDto.isActive = false;\n+\t\t\t\t\tupdateOrderDto.profit = subtract(\n+\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\tsubtract(\n+\t\t\t\t\t\t\t\ttotalAmount2,\n+\t\t\t\t\t\t\t\tparentOrder.amount2\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfeeInCurrency2Cost\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tparentOrder.fee\n+\t\t\t\t\t);\n+\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n+\n+\t\t\t\t}\n+\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n+\n+\t\t\t\tthis.log.info('Order closed',\n+\t\t\t\t\tparentOrder.id, '=>', order.id,\n+\t\t\t\t\t'Profit: ',\n+\t\t\t\t\tupdateOrderDto.profit,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\treturn order;\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\n+\t\t});\n+\t}\n+\n+\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n+\t\tconst fee = feeObj[0];\n+\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n+\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n+\t\tconst feeCurrency = fee?.currency;\n+\n+\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n+\t}\n+\n+\n+\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n+\n+\t\tconst api = this.api(accountId);\n+\t\tconst pair = currency1 + '/' + currency2;\n+\n+\t\treturn await lock.acquire('Balance' + accountId, async () => {\n+\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n+\n+\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\n+\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n+\n+\t\t\t\t// store in db\n+\t\t\t\tconst order = await this.orders.create({\n+\t\t\t\t\tcurrency1,\n+\t\t\t\t\tcurrency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: extOrder.cost,\n+\t\t\t\t\tfee: feeInCurrency2Cost,\n+\t\t\t\t\taccountId\n+\t\t\t\t});\n+\n+\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n+\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n+\t\t\t\tif (feeCost && feeCurrency) {\n+\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n+\t\t\t\t}\n+\n+\t\t\t\tthis.log.info(\n+\t\t\t\t\t\"New order\",\n+\t\t\t\t\torder.extOrderId,\n+\t\t\t\t\torder.rate,\n+\t\t\t\t\torder.amount1,\n+\t\t\t\t\torder.amount2,\n+\t\t\t\t\textOrder,\n+\t\t\t\t);\n+\n+\t\t\t\treturn { extOrder, order };\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n+\t}\n+\n+\n+\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n+\n+\t\tif (!fee || !fee.cost || fee.cost == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (!fee.currency)\n+\t\t\treturn fee.cost;\n+\n+\t\tif (fee.currency != currency2) {\n+\t\t\tconst pair = fee.currency + '/' + currency2;\n+\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n+\t\t\tif (!lastPrice) {\n+\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n+\t\t\t}\n+\n+\t\t\treturn multiply(fee.cost, lastPrice);\n+\n+\t\t} else {\n+\t\t\treturn fee.cost;\n+\t\t}\n+\t}\n+\n+\n+\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n+\n+\t\tlet closeOrder: Order;\t\t\n+\t\tconst api = this.api(order.accountId);\n+\t\tconst pair = order.currency1 + '/' + order.currency2;\n+\t\tlet extOrder;\n+\n+\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n+\n+\t\t\textOrder = await api.createOrder(pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n+\n+\t\t\tif (extOrder.id != undefined) {\n+\t\t\t\t// store in db\n+\t\t\t\tcloseOrder = await this.orders.create({\n+\t\t\t\t\tcurrency1: order.currency1,\n+\t\t\t\t\tcurrency2: order.currency2,\n+\t\t\t\t\textOrderId: extOrder.id,\n+\t\t\t\t\texpectedRate: price,\n+\t\t\t\t\trate: extOrder.price,\n+\t\t\t\t\tamount1: extOrder.amount,\n+\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n+\t\t\t\t\tparentId: order.id,\n+\t\t\t\t\tside: OrderSideEnum.SELL,\n+\t\t\t\t\taccountId: order.accountId\n+\t\t\t\t});\n+\t\t\t\tthis.log.info(\"New close order\",\n+\t\t\t\t\torder.id, ' => ', closeOrder.id,\n+\t\t\t\t\tcloseOrder.extOrderId,\n+\t\t\t\t\tcloseOrder.rate,\n+\t\t\t\t\tcloseOrder.amount1,\n+\t\t\t\t\tcloseOrder.amount2,\n+\t\t\t\t\textOrder\n+\t\t\t\t);\n+\n+\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n+\n+\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n+\n+\t\t\t}\n+\t\t});\n+\n+\t\t// You cant move it up due node lock\n+\t\tif (closeOrder)\n+\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n+\n+\n+\t\treturn closeOrder;\n+\t}\n+\n+\n+\tasync checkCloseOrders(): Promise<Array<Order>> {\n+\t\tconst closedOrders: Array<Order> = [];\n+\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n+\t\tfor (const order of orders) {\n+\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n+\t\t\tif (closedOrder)\n+\t\t\t\tclosedOrders.push(closedOrder);\n+\t\t}\n+\n+\t\treturn closedOrders;\n+\n+\t}\n+\n+\tasync syncData(accountId: number) {\n+\n+\t\tthis.log.info('Sync data ....');\n+\n+\t\t// Загружаем лимиты @todo вынеси в publicApi\t\t\n+\n+\t\tthis.log.info('Ok');\n+\t}\n+\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559306389,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -242,292 +242,5 @@\n \t\treturn closedOrders;\n \n \t}\n \n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\t\t\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { UpdateOrderDto } from \"../order/dto/update-order.dto\";\n-import { lock, sleep, SEC_IN_YEAR, checkLimits } from \"../helpers\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { OperationType } from \"../balance/entities/balanceLog.entity\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-interface Config {\n-\tpair: string,\n-\torderAmount: number,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\torderProbability: number,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-\n-}\n-\n-@Injectable()\n-export class BotService {\n-\n-\n-\n-\tconstructor(\n-\n-\t\tpublic balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate log: FileLogService,\n-\t\tpublic publicApi: PublicApiService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate pairs: PairService\n-\n-\t) { }\n-\n-\n-\tsetConfig(config) {\n-\t\tthis.config = config;\n-\t}\n-\n-\n-\tprivate api(accountId): ApiService {\n-\t\treturn this.accounts.getApiForAccount(accountId);\n-\t}\n-\n-\n-\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n-\t\t\n-\t\tconst api = this.api(order.accountId);\n-\n-\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\tthis.log.info('Check close order', order.extOrderId);\n-\n-\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n-\t\t\t\treturn;\n-\n-\t\t\tif (!extOrder)\n-\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n-\n-\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n-\n-\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n-\n-\t\t\t\tawait this.balance.income(order.accountId, order.currency2, OperationType.SELL, order.amount2);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency,OperationType.SELL_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\t// Fill parent buy-order\n-\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n-\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n-\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n-\t\t\t\t};\n-\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n-\n-\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n-\t\t\t\t\tupdateOrderDto.isActive = false;\n-\t\t\t\t\tupdateOrderDto.profit = subtract(\n-\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\tsubtract(\n-\t\t\t\t\t\t\t\ttotalAmount2,\n-\t\t\t\t\t\t\t\tparentOrder.amount2\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tfeeInCurrency2Cost\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparentOrder.fee\n-\t\t\t\t\t);\n-\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n-\n-\t\t\t\t}\n-\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n-\n-\t\t\t\tthis.log.info('Order closed',\n-\t\t\t\t\tparentOrder.id, '=>', order.id,\n-\t\t\t\t\t'Profit: ',\n-\t\t\t\t\tupdateOrderDto.profit,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\treturn order;\n-\t\t\t}\n-\n-\t\t\treturn false;\n-\n-\t\t});\n-\t}\n-\n-\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n-\t\tconst fee = feeObj[0];\n-\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n-\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n-\t\tconst feeCurrency = fee?.currency;\n-\n-\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n-\t}\n-\n-\n-\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n-\n-\t\tconst api = this.api(accountId);\n-\t\tconst pair = currency1 + '/' + currency2;\n-\n-\t\treturn await lock.acquire('Balance' + accountId, async () => {\n-\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n-\n-\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\n-\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n-\n-\t\t\t\t// store in db\n-\t\t\t\tconst order = await this.orders.create({\n-\t\t\t\t\tcurrency1,\n-\t\t\t\t\tcurrency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: extOrder.cost,\n-\t\t\t\t\tfee: feeInCurrency2Cost,\n-\t\t\t\t\taccountId\n-\t\t\t\t});\n-\n-\t\t\t\tawait this.balance.income(accountId, order.currency1, OperationType.BUY, extOrder.amount);\n-\t\t\t\tawait this.balance.outcome(accountId, order.currency2, OperationType.BUY, extOrder.cost);\n-\t\t\t\tif (feeCost && feeCurrency) {\n-\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, OperationType.BUY_FEE, feeCost);\n-\t\t\t\t}\n-\n-\t\t\t\tthis.log.info(\n-\t\t\t\t\t\"New order\",\n-\t\t\t\t\torder.extOrderId,\n-\t\t\t\t\torder.rate,\n-\t\t\t\t\torder.amount1,\n-\t\t\t\t\torder.amount2,\n-\t\t\t\t\textOrder,\n-\t\t\t\t);\n-\n-\t\t\t\treturn { extOrder, order };\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n-\n-\n-\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n-\n-\t\tif (!fee || !fee.cost || fee.cost == 0)\n-\t\t\treturn 0;\n-\n-\t\tif (!fee.currency)\n-\t\t\treturn fee.cost;\n-\n-\t\tif (fee.currency != currency2) {\n-\t\t\tconst pair = fee.currency + '/' + currency2;\n-\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n-\t\t\tif (!lastPrice) {\n-\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n-\t\t\t}\n-\n-\t\t\treturn multiply(fee.cost, lastPrice);\n-\n-\t\t} else {\n-\t\t\treturn fee.cost;\n-\t\t}\n-\t}\n-\n-\n-\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n-\n-\t\tlet closeOrder: Order;\t\t\n-\t\tconst api = this.api(order.accountId);\n-\t\tconst pair = order.currency1 + '/' + order.currency2;\n-\t\tlet extOrder;\n-\n-\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n-\n-\t\t\textOrder = await api.createOrder(pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n-\n-\t\t\tif (extOrder.id != undefined) {\n-\t\t\t\t// store in db\n-\t\t\t\tcloseOrder = await this.orders.create({\n-\t\t\t\t\tcurrency1: order.currency1,\n-\t\t\t\t\tcurrency2: order.currency2,\n-\t\t\t\t\textOrderId: extOrder.id,\n-\t\t\t\t\texpectedRate: price,\n-\t\t\t\t\trate: extOrder.price,\n-\t\t\t\t\tamount1: extOrder.amount,\n-\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n-\t\t\t\t\tparentId: order.id,\n-\t\t\t\t\tside: OrderSideEnum.SELL,\n-\t\t\t\t\taccountId: order.accountId\n-\t\t\t\t});\n-\t\t\t\tthis.log.info(\"New close order\",\n-\t\t\t\t\torder.id, ' => ', closeOrder.id,\n-\t\t\t\t\tcloseOrder.extOrderId,\n-\t\t\t\t\tcloseOrder.rate,\n-\t\t\t\t\tcloseOrder.amount1,\n-\t\t\t\t\tcloseOrder.amount2,\n-\t\t\t\t\textOrder\n-\t\t\t\t);\n-\n-\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n-\n-\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n-\n-\t\t\t}\n-\t\t});\n-\n-\t\t// You cant move it up due node lock\n-\t\tif (closeOrder)\n-\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n-\n-\n-\t\treturn closeOrder;\n-\t}\n-\n-\n-\tasync checkCloseOrders(): Promise<Array<Order>> {\n-\t\tconst closedOrders: Array<Order> = [];\n-\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n-\t\tfor (const order of orders) {\n-\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n-\t\t\tif (closedOrder)\n-\t\t\t\tclosedOrders.push(closedOrder);\n-\t\t}\n-\n-\t\treturn closedOrders;\n-\n-\t}\n-\n-\tasync syncData(accountId: number) {\n-\n-\t\tthis.log.info('Sync data ....');\n-\n-\t\t// Загружаем лимиты @todo вынеси в publicApi\t\t\n-\n-\t\tthis.log.info('Ok');\n-\t}\n-\n-\n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1691542093089,
            "name": "Commit-0",
            "content": "import { Injectable } from \"@nestjs/common\";\nimport { BalanceService } from \"../balance/balance.service\";\nimport { OrderService } from \"../order/order.service\";\nimport { Order, OrderSideEnum } from \"../order/entities/order.entity\";\nimport { UpdateOrderDto } from \"../order/dto/update-order.dto\";\nimport { lock, sleep, SEC_IN_YEAR } from \"../helpers\";\nimport { ApiService } from \"../exchange/api.service\";\nimport { FileLogService } from \"../log/filelog.service\";\nimport { AccountService } from \"../exchange/account.service\";\nimport { PublicApiService } from \"../exchange/publicApi.service\";\nimport { PairService } from \"../exchange/pair.service\";\nimport { OperationType } from \"../balance/entities/balanceLog.entity\";\n\n\nconst { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n\ninterface Config {\n\tpair: string,\n\torderAmount: number,\n\tcurrency1: string,\n\tcurrency2: string,\n\torderProbability: number,\n\tminDailyProfit: number,\n\tminYearlyProfit: number,\n\tminBuyRateMarginToProcess: number,\n\tminSellRateMarginToProcess: number,\n\tbuyFee: number,\n\tsellFee: number,\n\n}\n\n@Injectable()\nexport class BotService {\n\n\n\tprivate minAmount: number;\n\tprivate minCost: number;\n\tprivate config: any = {};\n\n\tconstructor(\n\n\t\tpublic balance: BalanceService,\n\t\tprivate orders: OrderService,\n\t\tprivate log: FileLogService,\n\t\tpublic publicApi: PublicApiService,\n\t\tprivate accounts: AccountService,\n\t\tprivate pairs: PairService\n\n\t) { }\n\n\n\tsetConfig(config) {\n\t\tthis.config = config;\n\t}\n\n\n\tprivate accountConfig(accountId): Config {\n\t\treturn this.accounts.getConfig(accountId);\n\t}\n\n\tprivate api(accountId): ApiService {\n\t\treturn this.accounts.getApiForAccount(accountId);\n\t}\n\n\n\tpublic async checkCloseOrder(order: Order, extOrder?): Promise<Order> {\n\n\t\tconst accountId = order.accountId;\n\t\tconst config = this.accountConfig(accountId);\n\t\tconst api = this.api(order.accountId);\n\n\t\treturn await lock.acquire('Balance' + order.accountId, async () => {\n\n\t\t\tthis.log.info('Check close order', order.extOrderId);\n\n\t\t\tif (!order.isActive || order.side != OrderSideEnum.SELL)\n\t\t\t\treturn;\n\n\t\t\tif (!extOrder)\n\t\t\t\textOrder = await api.fetchOrder(Number(order.extOrderId), order.pairTitle);\n\n\t\t\tif (compareTo(extOrder.filled, extOrder.amount) == 0) {\n\n\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, order.currency2);\n\n\t\t\t\tawait this.orders.update(order.id, { isActive: false, filled: extOrder.filled, fee: feeInCurrency2Cost });\n\n\t\t\t\tawait this.balance.income(order.accountId, order.currency2, order.amount2);\n\t\t\t\tif (feeCost && feeCurrency) {\n\t\t\t\t\tawait this.balance.outcome(order.accountId, feeCurrency, feeCost);\n\t\t\t\t}\n\n\t\t\t\t// Fill parent buy-order\n\t\t\t\tconst parentOrder = await this.orders.findOne({ id: order.parentId });\n\t\t\t\tconst updateOrderDto: UpdateOrderDto = {\n\t\t\t\t\tfilled: add(parentOrder.filled, extOrder.filled)\n\t\t\t\t};\n\t\t\t\tif (compareTo(parentOrder.amount1, updateOrderDto.filled) == 0) {\n\n\t\t\t\t\tconst totalAmount2 = await this.orders.getSumByParentId(parentOrder.id, 'amount2');\n\t\t\t\t\tupdateOrderDto.isActive = false;\n\t\t\t\t\tupdateOrderDto.profit = subtract(\n\t\t\t\t\t\tsubtract(\n\t\t\t\t\t\t\tsubtract(\n\t\t\t\t\t\t\t\ttotalAmount2,\n\t\t\t\t\t\t\t\tparentOrder.amount2\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfeeInCurrency2Cost\n\t\t\t\t\t\t),\n\t\t\t\t\t\tparentOrder.fee\n\t\t\t\t\t);\n\t\t\t\t\tupdateOrderDto.profitPc = divide(multiply(SEC_IN_YEAR, updateOrderDto.profit), (order.createdAtSec - parentOrder.createdAtSec), 15)\n\n\t\t\t\t}\n\t\t\t\tawait this.orders.update(parentOrder.id, updateOrderDto);\n\n\t\t\t\tthis.log.info('Order closed',\n\t\t\t\t\tparentOrder.id, '=>', order.id,\n\t\t\t\t\t'Profit: ',\n\t\t\t\t\tupdateOrderDto.profit,\n\t\t\t\t\textOrder\n\t\t\t\t);\n\n\t\t\t\treturn order;\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t});\n\t}\n\tpublic async tryToBuy(accountId: number, rate: number): Promise<any> {\n\n\t\tconst config = this.accountConfig(accountId);\n\t\tconst amount1: number = this.checkLimits(rate, config.orderAmount);\n\t\tconst amount2: number = multiply(rate, amount1);\n\t\tconst balance2: number = await this.balance.getBalanceAmount(accountId, config.currency2);\n\n\t\tif (compareTo(balance2, amount2) > 0) {\n\n\t\t\treturn await this.createBuyOrder(\n\t\t\t\taccountId,\n\t\t\t\tconfig.currency1,\n\t\t\t\tconfig.currency2,\n\t\t\t\trate,\n\t\t\t\tamount1\n\t\t\t);\n\n\t\t} else {\n\t\t\tthis.log.info('Cant buy, needs ' + amount2 + ' but have only ' + balance2);\n\t\t\tawait sleep(60);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\t/**\n\t * \n\t * @param price Fix amount to limits\n\t * @param amount1 \n\t * @returns \n\t */\n\tprivate checkLimits(price: number, amount1: number) {\n\t\tif (compareTo(amount1, this.minAmount) < 0)\n\t\t\tamount1 = this.minAmount;\n\n\t\tconst amount2 = multiply(price, amount1);\n\t\tif (compareTo(amount2, this.minCost) < 0) {\n\t\t\tamount1 = divide(this.minCost * 1.1, price, 6);\n\t\t}\n\n\t\treturn amount1;\n\t}\n\n\n\n\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n\n\n\t\tthis.log.info('Get active orders....');\n\t\tconst tm = Date.now();\n\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n\t\t\tthis.config.buyFee,\n\t\t\tthis.config.sellFee,\n\t\t\tthis.config.minDailyProfit,\n\t\t\tthis.config.minYearlyProfit\n\t\t);\n\n\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n\n\n\t\tfor (const order of orders) {\n\t\t\tawait this.createCloseOrder(order.buyRate, order);\n\t\t}\n\n\t\treturn orders;\n\t}\n\n\tasync extractFee(feeObj: { cost: number; currency: string; }[], currency2: string) {\n\t\tconst fee = feeObj[0];\n\t\tconst feeCost = feeObj[0]?.cost ?? 0;\n\t\tconst feeInCurrency2Cost = await this.calculateFee(feeObj[0], currency2);\n\t\tconst feeCurrency = fee?.currency;\n\n\t\treturn { feeCost, feeInCurrency2Cost, feeCurrency };\n\t}\n\n\n\tpublic async createBuyOrder(accountId: number, currency1: string, currency2: string, price: number, amount1: number) {\n\n\t\tconst api = this.api(accountId);\n\t\tconst pair = currency1 + '/' + currency2;\n\n\t\treturn await lock.acquire('Balance' + accountId, async () => {\n\t\t\tthis.log.info('Try to buy', price, amount1, multiply(amount1, price));\n\n\t\t\tconst extOrder = await api.createOrder(pair, 'market', 'buy', amount1);\n\n\t\t\tif (extOrder.id != undefined) {\n\n\t\t\t\tconst { feeCost, feeInCurrency2Cost, feeCurrency } = await this.extractFee(extOrder.fees, currency2);\n\n\t\t\t\t// store in db\n\t\t\t\tconst order = await this.orders.create({\n\t\t\t\t\tcurrency1,\n\t\t\t\t\tcurrency2,\n\t\t\t\t\textOrderId: extOrder.id,\n\t\t\t\t\texpectedRate: price,\n\t\t\t\t\trate: extOrder.price,\n\t\t\t\t\tamount1: extOrder.amount,\n\t\t\t\t\tamount2: extOrder.cost,\n\t\t\t\t\tfee: feeInCurrency2Cost,\n\t\t\t\t\taccountId\n\t\t\t\t});\n\n\t\t\t\tawait this.balance.income(accountId, order.currency1, extOrder.amount);\n\t\t\t\tawait this.balance.outcome(accountId, order.currency2, extOrder.cost);\n\t\t\t\tif (feeCost && feeCurrency) {\n\t\t\t\t\tawait this.balance.outcome(accountId, feeCurrency, feeCost);\n\t\t\t\t}\n\n\t\t\t\tthis.log.info(\n\t\t\t\t\t\"New order\",\n\t\t\t\t\torder.extOrderId,\n\t\t\t\t\torder.rate,\n\t\t\t\t\torder.amount1,\n\t\t\t\t\torder.amount2,\n\t\t\t\t\textOrder,\n\t\t\t\t);\n\n\t\t\t\treturn { extOrder, order };\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n\n\n\tprivate async calculateFee(fee: { cost: number; currency: string; }, currency2: string) {\n\n\t\tif (!fee || !fee.cost || fee.cost == 0)\n\t\t\treturn 0;\n\n\t\tif (!fee.currency)\n\t\t\treturn fee.cost;\n\n\t\tif (fee.currency != currency2) {\n\t\t\tconst pair = fee.currency + '/' + currency2;\n\t\t\tconst { lastPrice } = await this.pairs.getOrRefreshPair(fee.currency, currency2);\n\t\t\tif (!lastPrice) {\n\t\t\t\tthrow new Error(\"Unknown fee pair\" + lastPrice);\n\t\t\t}\n\n\t\t\treturn multiply(fee.cost, lastPrice);\n\n\t\t} else {\n\t\t\treturn fee.cost;\n\t\t}\n\t}\n\n\n\tpublic async createCloseOrder(price: number, order: Order): Promise<Order> {\n\n\t\tlet closeOrder: Order;\n\t\tconst accountId = order.accountId;\n\t\tconst config = this.accountConfig(accountId);\n\t\tconst api = this.api(order.accountId);\n\t\tlet extOrder;\n\n\t\tawait lock.acquire('Balance' + order.accountId, async () => {\n\n\t\t\textOrder = await api.createOrder(config.pair, 'limit', 'sell', subtract(order.amount1, order.prefilled), price);\n\n\t\t\tif (extOrder.id != undefined) {\n\t\t\t\t// store in db\n\t\t\t\tcloseOrder = await this.orders.create({\n\t\t\t\t\tcurrency1: order.currency1,\n\t\t\t\t\tcurrency2: order.currency2,\n\t\t\t\t\textOrderId: extOrder.id,\n\t\t\t\t\texpectedRate: price,\n\t\t\t\t\trate: extOrder.price,\n\t\t\t\t\tamount1: extOrder.amount,\n\t\t\t\t\tamount2: multiply(extOrder.amount, extOrder.price),\n\t\t\t\t\tparentId: order.id,\n\t\t\t\t\tside: OrderSideEnum.SELL,\n\t\t\t\t\taccountId: order.accountId\n\t\t\t\t});\n\t\t\t\tthis.log.info(\"New close order\",\n\t\t\t\t\torder.id, ' => ', closeOrder.id,\n\t\t\t\t\tcloseOrder.extOrderId,\n\t\t\t\t\tcloseOrder.rate,\n\t\t\t\t\tcloseOrder.amount1,\n\t\t\t\t\tcloseOrder.amount2,\n\t\t\t\t\textOrder\n\t\t\t\t);\n\n\t\t\t\tawait this.balance.outcome(order.accountId, order.currency1, OperationType.SELL, closeOrder.amount1);\n\n\t\t\t\tawait this.orders.update(order.id, { prefilled: add(order.prefilled, extOrder.amount) })\n\n\t\t\t}\n\t\t});\n\n\t\t// You cant move it up due node lock\n\t\tif (closeOrder)\n\t\t\tawait this.checkCloseOrder(closeOrder, extOrder);\n\n\n\t\treturn closeOrder;\n\t}\n\n\n\tasync checkCloseOrders(): Promise<Array<Order>> {\n\t\tconst closedOrders: Array<Order> = [];\n\t\tconst orders = await this.orders.findAll({ isActive: true, side: OrderSideEnum.SELL });\n\t\tfor (const order of orders) {\n\t\t\tconst closedOrder = await this.checkCloseOrder(order);\n\t\t\tif (closedOrder)\n\t\t\t\tclosedOrders.push(closedOrder);\n\t\t}\n\n\t\treturn closedOrders;\n\n\t}\n\n\tasync syncData(accountId: number) {\n\n\t\tthis.log.info('Sync data ....');\n\n\t\t// Загружаем лимиты @todo вынеси в publicApi\n\t\t({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n\n\t\tthis.log.info('Ok');\n\t}\n\n\n}"
        }
    ]
}