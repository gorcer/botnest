{
    "sourceFile": "src/bot/lonelyTrader.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 61,
            "patches": [
                {
                    "date": 1691545811389,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1691545902664,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,245 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\tawait this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tthis.loadActiveOrders();\n+\t\t\t\t\t}\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\n+\n+\t\t\t\t// Загрузить открытые ордера\n+\t\t\t\tawait this.loadActiveOrders();\n+\t\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691545956952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,245 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tthis.loadActiveOrders();\n+\t\t\t\t\t}\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\n+\n+\t\t\t\t// Загрузить открытые ордера\n+\t\t\t\tawait this.loadActiveOrders();\n+\t\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691545997010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,245 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tthis.loadActiveOrders();\n+\t\t\t\t\t}\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\n+\n+\t\t\t\t// Загрузить открытые ордера\n+\t\t\t\tawait this.loadActiveOrders();\n+\t\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691553479361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,8 +9,9 @@\n import { OrderService } from \"../order/order.service\";\n import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n import { ApiService } from \"../exchange/api.service\";\n import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n \n const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n \n \n@@ -38,9 +39,10 @@\n \t\tprivate log: FileLogService,\n \t\tprivate accounts: AccountService,\n \t\tprivate balance: BalanceService,\n \t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n \n \t) {\n \n \t\tthis.config = {\n@@ -150,253 +152,10 @@\n \t\t\t}\n \t\t}\n \t}\n \n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n \n \n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n-\n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tthis.loadActiveOrders();\n-\t\t\t\t\t}\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \tprivate async prepare() {\n \t\tlet syncStatus = false;\n \n \n@@ -486,496 +245,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\tawait this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tthis.loadActiveOrders();\n-\t\t\t\t\t}\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n-\n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\n-\t\t\t\t\t\tawait this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tthis.loadActiveOrders();\n-\t\t\t\t\t}\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n-\n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691553516895,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,249 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tthis.loadActiveOrders();\n+\t\t\t\t\t}\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\n+\n+\t\t\t\t// Загрузить открытые ордера\n+\t\t\t\tawait this.loadActiveOrders();\n+\t\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691553526232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -245,254 +245,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tthis.loadActiveOrders();\n-\t\t\t\t\t}\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n-\n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691553540769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,249 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tthis.loadActiveOrders();\n+\t\t\t\t\t}\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\n+\n+\t\t\t\t// Загрузить открытые ордера\n+\t\t\t\tawait this.loadActiveOrders();\n+\t\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691553670977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,254 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tthis.loadActiveOrders();\n+\t\t\t\t\t}\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst accounts = this.accountsReadyToBuy.get(this.config.)\n+\t}\n+\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\n+\n+\t\t\t\t// Загрузить открытые ордера\n+\t\t\t\tawait this.loadActiveOrders();\n+\t\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691553689476,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,9 +155,9 @@\n \t\t}\n \t}\n \n \tasync tryToBuy() {\n-\t\tconst accounts = this.accountsReadyToBuy.get(this.config.)\n+\t\tconst accounts = this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n \t}\n \n \n \tprivate async prepare() {\n@@ -250,503 +250,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tthis.loadActiveOrders();\n-\t\t\t\t\t}\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n-\n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tthis.loadActiveOrders();\n-\t\t\t\t\t}\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n-\n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691553971963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,266 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tthis.loadActiveOrders();\n+\t\t\t\t\t}\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(await this.createBuyOrder(\n+\t\t\t\t\taccountId,\n+\t\t\t\t\tconfig.currency1,\n+\t\t\t\t\tconfig.currency2,\n+\t\t\t\t\trate,\n+\t\t\t\t\tamount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\n+\n+\t\t\t\t// Загрузить открытые ордера\n+\t\t\t\tawait this.loadActiveOrders();\n+\t\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691553989673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,14 +159,14 @@\n \t\tconst orders=[];\n \t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n \t\tfor(const account of accounts) {\n \t\t\torders.push(\n-\t\t\t\t(await this.createBuyOrder(\n-\t\t\t\t\taccountId,\n-\t\t\t\t\tconfig.currency1,\n-\t\t\t\t\tconfig.currency2,\n-\t\t\t\t\trate,\n-\t\t\t\t\tamount1\n+\t\t\t\t(await this.bot.createBuyOrder(\n+\t\t\t\t\taccounts.accountId,\n+\t\t\t\t\taccounts.currency1,\n+\t\t\t\t\taccounts.currency2,\n+\t\t\t\t\taccounts.rate,\n+\t\t\t\t\taccounts.amount1\n \t\t\t\t))\n \t\t\t);\n \t\t}\n \t}\n@@ -262,259 +262,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tthis.loadActiveOrders();\n-\t\t\t\t\t}\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst accounts = this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t}\n-\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n-\n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554000716,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,8 +168,10 @@\n \t\t\t\t\taccounts.amount1\n \t\t\t\t))\n \t\t\t);\n \t\t}\n+\n+\t\treturn orders;\n \t}\n \n \n \tprivate async prepare() {\n"
                },
                {
                    "date": 1691554027376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,268 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tthis.loadActiveOrders();\n+\t\t\t\t\t}\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(await this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\n+\n+\t\t\t\t// Загрузить открытые ордера\n+\t\t\t\tawait this.loadActiveOrders();\n+\t\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554076000,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,266 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(await this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\n+\n+\t\t\t\t// Загрузить открытые ордера\n+\t\t\t\tawait this.loadActiveOrders();\n+\t\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554083489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,14 +185,10 @@\n \n \t\t\t\tawait this.bot.syncData(this.accountId);\n \n \t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n \n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n \t\t\t\tsyncStatus = true;\n \t\t\t} catch (e) {\n \n \t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n@@ -262,541 +258,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tthis.loadActiveOrders();\n-\t\t\t\t\t}\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(await this.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n-\n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tthis.loadActiveOrders();\n-\t\t\t\t\t}\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(await this.bot.createBuyOrder(\n-\t\t\t\t\taccounts.accountId,\n-\t\t\t\t\taccounts.currency1,\n-\t\t\t\t\taccounts.currency2,\n-\t\t\t\t\taccounts.rate,\n-\t\t\t\t\taccounts.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\n-\n-\t\t\t\t// Загрузить открытые ордера\n-\t\t\t\tawait this.loadActiveOrders();\n-\t\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554123909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,262 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(await this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554149140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,266 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t}\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(await this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554162361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -262,529 +262,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(await this.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(await this.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554209614,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,9 +131,9 @@\n \t\t\t\t}\n \n \t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n \t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\t;\n \t\t\t\t\tif (result) {\n \t\t\t\t\t\tconst {order} = result;\n \t\t\t\t\t\tthis.activeOrders.push(order);\n \n"
                },
                {
                    "date": 1691554375912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -127,13 +127,17 @@\n \t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n \n \t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n \t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\n+\t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n \t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\t;\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n \t\t\t\t\tif (result) {\n \t\t\t\t\t\tconst {order} = result;\n \t\t\t\t\t\tthis.activeOrders.push(order);\n \n@@ -157,20 +161,20 @@\n \t\t}\n \t}\n \n \tasync tryToBuy() {\n-\t\tconst orders=[];\n+\t\t\n \t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n \t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(await this.bot.createBuyOrder(\n+\t\t\t\n+\t\t\t\tthis.bot.createBuyOrder(\n \t\t\t\t\taccount.accountId,\n \t\t\t\t\taccount.currency1,\n \t\t\t\t\taccount.currency2,\n \t\t\t\t\taccount.rate,\n \t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n+\t\t\t\t);\n+\t\t\t\n \t\t}\n \n \t\treturn orders;\n \t}\n"
                },
                {
                    "date": 1691554383527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,21 +163,19 @@\n \n \tasync tryToBuy() {\n \t\t\n \t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\t\n+\t\tfor(const account of accounts) {\t\t\t\n \t\t\t\tthis.bot.createBuyOrder(\n \t\t\t\t\taccount.accountId,\n \t\t\t\t\taccount.currency1,\n \t\t\t\t\taccount.currency2,\n \t\t\t\t\taccount.rate,\n \t\t\t\t\taccount.amount1\n-\t\t\t\t);\n-\t\t\t\n+\t\t\t\t);\t\t\t\n \t\t}\n \n-\t\treturn orders;\n+\t\t\n \t}\n \n \n \tprivate async prepare() {\n"
                },
                {
                    "date": 1691554428346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,270 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif ((orders.length>0) {\n+\t\t\t\t\t\t\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n+\t\t\t\t\tif (result) {\n+\t\t\t\t\t\tconst {order} = result;\n+\t\t\t\t\t\tthis.activeOrders.push(order);\n+\n+\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n+\t\t\t\t\t\t// await this.checkBalance();\n+\t\t\t\t\t}\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(await this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn Promise.all(orders);\n+\t}\n+\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554465447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -128,10 +128,10 @@\n \n \t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n \t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n \t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif ((orders.length>0) {\n-\t\t\t\t\t\t\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n@@ -165,9 +165,9 @@\n \t\tconst orders=[];\n \t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n \t\tfor(const account of accounts) {\n \t\t\torders.push(\n-\t\t\t\t(await this.bot.createBuyOrder(\n+\t\t\t\t(this.bot.createBuyOrder(\n \t\t\t\t\taccount.accountId,\n \t\t\t\t\taccount.currency1,\n \t\t\t\t\taccount.currency2,\n \t\t\t\t\taccount.rate,\n@@ -266,273 +266,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\t\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\t\t\t\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t);\t\t\t\n-\t\t}\n-\n-\t\t\n-\t}\n-\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554495187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,20 +133,8 @@\n \t\t\t\t\t\tawait this.checkCloseOrders();\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n-\t\t\t\t\tif (result) {\n-\t\t\t\t\t\tconst {order} = result;\n-\t\t\t\t\t\tthis.activeOrders.push(order);\n-\n-\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n-\t\t\t\t\t\t// await this.checkBalance();\n-\t\t\t\t\t}\t\t\t\t\t\n-\t\t\t\t}\n-\n \t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n \t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n \t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n \t\t\t\t\t\n"
                },
                {
                    "date": 1691554663363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,13 +41,20 @@\n \t\tprivate accounts: AccountService,\n \t\tprivate balance: BalanceService,\n \t\tprivate orders: OrderService,\n \t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\n+\t\tminDailyProfit: number,\n+\t\tminYearlyProfit: number,\n \n \t) {\n \n \t\tthis.config = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n \t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n \t\t\tcurrency1: process.env.BOT_CURRENCY1,\n \t\t\tcurrency2: process.env.BOT_CURRENCY2,\n \t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n@@ -166,9 +173,31 @@\n \n \t\treturn Promise.all(orders);\n \t}\n \n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n \n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n \tprivate async prepare() {\n \t\tlet syncStatus = false;\n \n \n"
                },
                {
                    "date": 1691554670150,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,11 @@\n \tcurrency1: string,\n \tcurrency2: string,\n \tminBuyRateMarginToProcess: number,\n \tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean\n+\tbalanceSync: boolean,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n }\n \n @Injectable()\n export class LonelyTraderService {\n@@ -42,10 +44,9 @@\n \t\tprivate balance: BalanceService,\n \t\tprivate orders: OrderService,\n \t\tprivate pairs: PairService,\n \t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\n-\t\tminDailyProfit: number,\n-\t\tminYearlyProfit: number,\n+\t\t\n \n \t) {\n \n \t\tthis.config = {\n"
                },
                {
                    "date": 1691554686109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,8 +24,10 @@\n \tminSellRateMarginToProcess: number,\n \tbalanceSync: boolean,\n \tminDailyProfit: number,\n \tminYearlyProfit: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n }\n \n @Injectable()\n export class LonelyTraderService {\n"
                },
                {
                    "date": 1691554691317,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,10 +45,9 @@\n \t\tprivate accounts: AccountService,\n \t\tprivate balance: BalanceService,\n \t\tprivate orders: OrderService,\n \t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\n-\t\t\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n \n \t) {\n \n \t\tthis.config = {\n"
                },
                {
                    "date": 1691554705865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -192,9 +192,9 @@\n \t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n \n \n \t\tfor (const order of orders) {\n-\t\t\tawait this.createCloseOrder(order.buyRate, order);\n+\t\t\tawait this.bot.createCloseOrder(order.buyRate, order);\n \t\t}\n \n \t\treturn orders;\n \t}\n"
                },
                {
                    "date": 1691554734997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,291 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn Promise.all(orders);\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.bot.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\t\tlet syncStatus = false;\n+\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554758457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,291 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn Promise.all(orders);\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.bot.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554769611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,9 +183,9 @@\n \n \n \t\tthis.log.info('Get active orders....');\n \t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n \t\t\tthis.config.buyFee,\n \t\t\tthis.config.sellFee,\n \t\t\tthis.config.minDailyProfit,\n \t\t\tthis.config.minYearlyProfit\n@@ -287,585 +287,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(this.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn Promise.all(orders);\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.bot.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(this.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn Promise.all(orders);\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.orders.getActiveOrdersAboveProfit(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.bot.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\t\tlet syncStatus = false;\n-\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554837679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,291 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn Promise.all(orders);\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\n+\t\tfor (const order of orders) {\n+\t\t\tawait this.bot.createCloseOrder(order.buyRate, order);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554863882,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,9 +194,9 @@\n \t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n \n \n \t\tfor (const order of orders) {\n-\t\t\tawait this.bot.createCloseOrder(order.buyRate, order);\n+\t\t\tthis.bot.createCloseOrder(order.buyRate, order);\n \t\t}\n \n \t\treturn orders;\n \t}\n@@ -287,296 +287,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.bot.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(this.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn Promise.all(orders);\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tawait this.bot.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554914922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,293 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn Promise.all(orders);\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691554926371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,295 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\torders.push(\n+\t\t\t\t(this.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t))\n+\t\t\t);\n+\t\t}\n+\n+\t\treturn Promise.all(orders);\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691555004783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,300 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(item => {\n+\t\t\t\t\torders.push(item);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691555015527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,300 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.bot.setConfig({\n+\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t});\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559093551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,293 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\n+\tminDailyProfit: number,\n+\tminYearlyProfit: number,\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559105894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,11 +19,9 @@\n interface Config {\n \torderAmount: number,\n \tpair: string,\n \tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n+\tcurrency2: string,\t\n \tbalanceSync: boolean,\n \tminDailyProfit: number,\n \tminYearlyProfit: number,\n \tbuyFee: number,\n@@ -289,1484 +287,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(item => {\n-\t\t\t\t\torders.push(item);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(this.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn Promise.all(orders);\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(this.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn Promise.all(orders);\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.bot.setConfig({\n-\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t});\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\torders.push(\n-\t\t\t\t(this.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t))\n-\t\t\t);\n-\t\t}\n-\n-\t\treturn Promise.all(orders);\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\n-\t\tfor (const order of orders) {\n-\t\t\tthis.bot.createCloseOrder(order.buyRate, order);\n-\t\t}\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559118036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,291 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig: { orderProbability: number; };\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.config.minDailyProfit,\n+\t\t\tthis.config.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559168803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n \n \taccountId = 1;\n \tconfig: Config;\n \tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n+\taccountConfig;\n \tactiveOrders:Array<Order>=[];\n \n \tconstructor(\n \n@@ -182,10 +182,10 @@\n \t\tconst tm = Date.now();\n \t\tconst orders = await this.activeOrdersAboveProfit.get(\n \t\t\tthis.config.buyFee,\n \t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n \t\t);\n \n \t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n \n@@ -287,296 +287,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\t\n-\tbalanceSync: boolean,\n-\tminDailyProfit: number,\n-\tminYearlyProfit: number,\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig: { orderProbability: number; };\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.config.minDailyProfit,\n-\t\t\tthis.config.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559184843,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,290 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\n+\torderAmount: number,\n+\tpair: string,\n+\tcurrency1: string,\n+\tcurrency2: string,\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig;\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\n+\tasync trade() {\n+\t\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\tawait this.bot.syncData(this.accountId);\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559235902,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,300 +52,9 @@\n \n \t\tthis.config = {\t\t\n \t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n \t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\n-\tasync trade() {\n-\t\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n \t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.accountConfig.minDailyProfit,\n-\t\t\tthis.accountConfig.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\n-\torderAmount: number,\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\t\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig;\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n \t\t\tcurrency1: process.env.BOT_CURRENCY1,\n \t\t\tcurrency2: process.env.BOT_CURRENCY2,\n \t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n \t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n@@ -353,9 +62,9 @@\n \t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n \t\t}\n \n \n-\t\tconst overalAccountConf = {\n+\t\tconst overalAccountConf = {\t\t\t\n \t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n \t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n \t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n \t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n@@ -384,17 +93,14 @@\n \t\t\t\t}\n \t\t\t});\n \t\t}\n \n-\n \t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n \t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n \t}\n \n \n-\n \tasync trade() {\n-\t\n \t\t\n \t\tlet\t\t\t\n \t\t\tlastBid: number = 1,\n \t\t\tlastStatUpdate = 0,\n"
                },
                {
                    "date": 1691559250400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,10 +15,9 @@\n \n const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n \n \n-interface Config {\n-\torderAmount: number,\n+interface Config {\t\n \tpair: string,\n \tcurrency1: string,\n \tcurrency2: string,\n \tminBuyRateMarginToProcess: number,\n"
                },
                {
                    "date": 1691559260324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,12 +15,9 @@\n \n const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n \n \n-interface Config {\t\n-\tpair: string,\n-\tcurrency1: string,\n-\tcurrency2: string,\n+interface Config {\t\t\n \tminBuyRateMarginToProcess: number,\n \tminSellRateMarginToProcess: number,\n \tbalanceSync: boolean,\t\n \tbuyFee: number,\n@@ -51,11 +48,8 @@\n \n \t\tthis.config = {\t\t\n \t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n \t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t\t\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n \t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n \t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n \t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n \t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n"
                },
                {
                    "date": 1691559292121,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,278 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\t\t\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig;\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\t\t\t\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\tasync trade() {\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\t\t\t\t\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559315789,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,9 +198,8 @@\n \n \t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n \t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n \t\t\t\tawait this.checkBalance();\n-\t\t\t\t\n \n \t\t\t\t// проверить состояние открытых ордеров\n \t\t\t\tawait this.checkCloseOrders();\t\t\t\n \n@@ -274,285 +273,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\t\t\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\t\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig;\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\t\t\t\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\tasync trade() {\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.accountConfig.minDailyProfit,\n-\t\t\tthis.accountConfig.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\tawait this.bot.syncData(this.accountId);\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559333840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,277 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { PublicApiService } from \"../exchange/publicApi.service\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\t\t\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig;\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\t\t\t\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\tasync trade() {\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559438415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,12 @@\n import { Inject, Injectable, Scope } from \"@nestjs/common\";\n import { BotService } from \"./bot.service\";\n import { FileLogService } from \"../log/filelog.service\";\n import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n import { AccountService } from \"../exchange/account.service\";\n import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n+import { Order } from \"../order/entities/order.entity\";\n import { ApiService } from \"../exchange/api.service\";\n import { PairService } from \"../exchange/pair.service\";\n import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n"
                },
                {
                    "date": 1691559486085,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -271,282 +271,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { PublicApiService } from \"../exchange/publicApi.service\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order, OrderSideEnum } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\t\t\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\t\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig;\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\t\t\t\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\tasync trade() {\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.config.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.accountConfig.minDailyProfit,\n-\t\t\tthis.accountConfig.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691559492641,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,275 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\t\t\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig;\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n+\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\t\t\t\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\tasync trade() {\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.config.buyFee,\n+\t\t\tthis.config.sellFee,\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691560067856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,10 +166,8 @@\n \n \t\tthis.log.info('Get active orders....');\n \t\tconst tm = Date.now();\n \t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n \t\t\tthis.accountConfig.minDailyProfit,\n \t\t\tthis.accountConfig.minYearlyProfit\n \t\t);\n \n@@ -271,280 +269,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\t\t\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\t\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig;\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\t\t\t\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\tasync trade() {\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.config.buyFee,\n-\t\t\tthis.config.sellFee,\n-\t\t\tthis.accountConfig.minDailyProfit,\n-\t\t\tthis.accountConfig.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691560077959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,271 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\t\t\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+\tbuyFee: number,\n+\tsellFee: number,\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig;\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\n+\t\tconst overalAccountConf = {\t\t\t\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\tasync trade() {\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691560084431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,10 +17,8 @@\n interface Config {\t\t\n \tminBuyRateMarginToProcess: number,\n \tminSellRateMarginToProcess: number,\n \tbalanceSync: boolean,\t\n-\tbuyFee: number,\n-\tsellFee: number,\n }\n \n @Injectable()\n export class LonelyTraderService {\n@@ -267,278 +265,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\t\t\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\t\n-\tbuyFee: number,\n-\tsellFee: number,\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig;\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n-\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\t\t\t\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\tasync trade() {\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.accountConfig.minDailyProfit,\n-\t\t\tthis.accountConfig.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691560095488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,267 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\t\t\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig;\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\t\tconst overalAccountConf = {\t\t\t\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n+\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\tasync trade() {\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691560221848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,279 +49,11 @@\n \t\t}\n \n \t\tconst overalAccountConf = {\t\t\t\n \t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\t\t\t\n \t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\tasync trade() {\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.accountConfig.minDailyProfit,\n-\t\t\tthis.accountConfig.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\t\t\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\t\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig;\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\n-\t\tconst overalAccountConf = {\t\t\t\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n \t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n \t\t\tcurrency1: process.env.BOT_CURRENCY1,\n \t\t\tcurrency2: process.env.BOT_CURRENCY2,\n \t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n \t\t};\n@@ -341,9 +73,8 @@\n \t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n \t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n \t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n \t\t\t\t\tisSandbox: false,\n-\n \t\t\t\t}\n \t\t\t});\n \t\t}\n \n"
                },
                {
                    "date": 1691560229157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,266 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\t\t\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig;\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\t\tconst overalAccountConf = {\t\t\t\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\t\t\t\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\t\t\t\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\tasync trade() {\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691560518949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,267 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\t\t\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig;\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\t\tconst overalAccountConf = {\t\t\t\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\t\t\t\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\t\t\t\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\tasync trade() {\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tthis.log.info('Find accounts to buy....');\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691560550761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,268 @@\n+import { Inject, Injectable, Scope } from \"@nestjs/common\";\n+import { BotService } from \"./bot.service\";\n+import { FileLogService } from \"../log/filelog.service\";\n+import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n+import { AccountService } from \"../exchange/account.service\";\n+import { BalanceService } from \"../balance/balance.service\";\n+import { OrderService } from \"../order/order.service\";\n+import { Order } from \"../order/entities/order.entity\";\n+import { ApiService } from \"../exchange/api.service\";\n+import { PairService } from \"../exchange/pair.service\";\n+import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+\n+const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n+\n+\n+interface Config {\t\t\n+\tminBuyRateMarginToProcess: number,\n+\tminSellRateMarginToProcess: number,\n+\tbalanceSync: boolean,\t\n+}\n+\n+@Injectable()\n+export class LonelyTraderService {\n+\n+\taccountId = 1;\n+\tconfig: Config;\n+\tapi:ApiService;\n+\taccountConfig;\n+\tactiveOrders:Array<Order>=[];\n+\n+\tconstructor(\n+\n+\t\tpublic bot: BotService,\n+\t\tprivate log: FileLogService,\n+\t\tprivate accounts: AccountService,\n+\t\tprivate balance: BalanceService,\n+\t\tprivate orders: OrderService,\n+\t\tprivate pairs: PairService,\n+\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n+\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n+\n+\t) {\n+\n+\t\tthis.config = {\t\t\n+\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n+\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n+\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n+\t\t}\n+\n+\t\tconst overalAccountConf = {\t\t\t\n+\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n+\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\t\t\t\n+\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n+\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n+\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n+\t\t\tcurrency2: process.env.BOT_CURRENCY2,\t\t\t\n+\t\t};\n+\n+\t\tif (process.env.BOT_TEST == 'true') {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n+\t\t\t\t\tisSandbox: true,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthis.accounts.setAccount(this.accountId, {\n+\t\t\t\t...overalAccountConf, ...{\n+\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n+\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n+\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n+\t\t\t\t\tisSandbox: false,\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n+\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n+\t}\n+\n+\n+\tasync trade() {\n+\t\t\n+\t\tlet\t\t\t\n+\t\t\tlastBid: number = 1,\n+\t\t\tlastStatUpdate = 0,\n+\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\n+\t\t\tawait this.prepare();\n+\n+\t\twhile (true) {\n+\n+\t\t\ttry {\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n+\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n+\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n+\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n+\t\t\t\t}\n+\n+\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n+\t\t\t\t\tconst orders = await this.tryToBuy();\n+\t\t\t\t\tif (orders.length>0) {\n+\t\t\t\t\t\tawait this.checkCloseOrders();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n+\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n+\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n+\t\t\t\t\t\n+\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n+\t\t\t\t}\n+\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n+\t\t\t\tawait sleep(60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tasync tryToBuy() {\n+\t\tconst orders=[];\t\t\n+\t\tconst result=[];\n+\t\tthis.log.info('Find accounts to buy....');\n+\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n+\t\tthis.log.info('Ok....'+accounts.length + ' accounts');\n+\t\tfor(const account of accounts) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createBuyOrder(\n+\t\t\t\t\taccount.accountId,\n+\t\t\t\t\taccount.currency1,\n+\t\t\t\t\taccount.currency2,\n+\t\t\t\t\taccount.rate,\n+\t\t\t\t\taccount.amount1\n+\t\t\t\t).then(order => {\n+\t\t\t\t\torders.push(order);\n+\t\t\t\t})\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(orders);\n+\n+\t\treturn orders;\n+\t}\n+\n+\t\n+\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n+\n+\n+\t\tthis.log.info('Get active orders....');\n+\t\tconst tm = Date.now();\n+\t\tconst orders = await this.activeOrdersAboveProfit.get(\n+\t\t\tthis.accountConfig.minDailyProfit,\n+\t\t\tthis.accountConfig.minYearlyProfit\n+\t\t);\n+\n+\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n+\n+\t\tconst result=[];\n+\t\tfor (const order of orders) {\n+\t\t\tresult.push(\n+\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n+\t\t\t);\n+\t\t}\n+\n+\t\tawait Promise.all(result);\n+\n+\t\treturn orders;\n+\t}\n+\n+\tprivate async prepare() {\n+\n+\t\tlet syncStatus = false;\n+\n+\t\twhile (!syncStatus) {\n+\t\t\ttry {\n+\n+\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n+\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n+\t\t\t\tawait this.checkBalance();\n+\n+\t\t\t\t// проверить состояние открытых ордеров\n+\t\t\t\tawait this.checkCloseOrders();\t\t\t\n+\n+\t\t\t\tsyncStatus = true;\n+\t\t\t} catch (e) {\n+\n+\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n+\t\t\t\tawait sleep(5 * 60);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n+\n+\t\tconst rateFrom = multiply(rate, (1-minMargin));\n+\t\tconst rateTo = multiply(rate, (1+minMargin));\n+\n+\t\tfor (const order of activeOrders) {\n+\t\t\tif (\n+\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n+\t\t\t\tcompareTo(order.rate, rateTo) < 0\n+\t\t\t) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t\t\n+\t}\n+\n+\tpublic async loadActiveOrders() {\n+\t\tthis.activeOrders = await this.orders.getActiveOrders();\n+\t\treturn this.activeOrders;\n+\t}\n+\n+\tprivate canBuy(accountId: any) {\n+\t\t// Пока это просто рандом\n+\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n+\t}\n+\n+\n+\tprivate async checkCloseOrders() {\n+\t\tconst closedOrders = await this.bot.checkCloseOrders();\n+\t\tif (closedOrders.length > 0) {\n+\n+\t\t\tawait this.checkBalance();\n+\n+\t\t}\n+\t}\n+\n+\tprivate async checkBalance() {\n+\t\tif (this.config.balanceSync)\n+\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n+\t}\n+\n+\n+\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n+\n+\t\tconst pair = currency1 + '/' + currency2;\n+\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n+\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n+\t\tconst rate = await this.api.getLastPrice(pair);\n+\n+\t\tthis.log.stat(\n+\t\t\tcurrency1,\n+\t\t\tbalance1,\n+\t\t\tcurrency2,\n+\t\t\tbalance2,\n+\t\t\t'Total in ' + currency2,\n+\t\t\tmultiply(rate, balance1)\n+\t\t);\n+\n+\n+\t}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691632797078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,10 +7,10 @@\n import { OrderService } from \"../order/order.service\";\n import { Order } from \"../order/entities/order.entity\";\n import { ApiService } from \"../exchange/api.service\";\n import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n+import { AccountsReadyToBuy } from \"../analitics/accountsReadyToBuy.service\";\n+import { ActiveOrdersAboveProfit } from \"../analitics/activeOrdersAboveProfit.service\";\n \n const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n \n \n@@ -264,805 +264,5 @@\n \n \n \t}\n \n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\t\t\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\t\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig;\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\t\tconst overalAccountConf = {\t\t\t\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\t\t\t\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\t\t\t\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\tasync trade() {\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tthis.log.info('Find accounts to buy....');\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.accountConfig.minDailyProfit,\n-\t\t\tthis.accountConfig.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\t\t\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\t\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig;\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\t\tconst overalAccountConf = {\t\t\t\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\t\t\t\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\t\t\t\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\tasync trade() {\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.accountConfig.minDailyProfit,\n-\t\t\tthis.accountConfig.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n-}\n-import { Inject, Injectable, Scope } from \"@nestjs/common\";\n-import { BotService } from \"./bot.service\";\n-import { FileLogService } from \"../log/filelog.service\";\n-import { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\n-import { AccountService } from \"../exchange/account.service\";\n-import { BalanceService } from \"../balance/balance.service\";\n-import { OrderService } from \"../order/order.service\";\n-import { Order } from \"../order/entities/order.entity\";\n-import { ApiService } from \"../exchange/api.service\";\n-import { PairService } from \"../exchange/pair.service\";\n-import { AccountsReadyToBuy } from \"./analitics/accountsReadyToBuy.service\";\n-import { ActiveOrdersAboveProfit } from \"./analitics/activeOrdersAboveProfit.service\";\n-\n-const { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n-\n-\n-interface Config {\t\t\n-\tminBuyRateMarginToProcess: number,\n-\tminSellRateMarginToProcess: number,\n-\tbalanceSync: boolean,\t\n-}\n-\n-@Injectable()\n-export class LonelyTraderService {\n-\n-\taccountId = 1;\n-\tconfig: Config;\n-\tapi:ApiService;\n-\taccountConfig;\n-\tactiveOrders:Array<Order>=[];\n-\n-\tconstructor(\n-\n-\t\tpublic bot: BotService,\n-\t\tprivate log: FileLogService,\n-\t\tprivate accounts: AccountService,\n-\t\tprivate balance: BalanceService,\n-\t\tprivate orders: OrderService,\n-\t\tprivate pairs: PairService,\n-\t\tprivate accountsReadyToBuy:AccountsReadyToBuy,\t\t\n-\t\tprivate activeOrdersAboveProfit:ActiveOrdersAboveProfit\n-\n-\t) {\n-\n-\t\tthis.config = {\t\t\n-\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n-\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n-\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n-\t\t}\n-\n-\t\tconst overalAccountConf = {\t\t\t\n-\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n-\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\t\t\t\n-\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n-\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n-\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n-\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n-\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n-\t\t};\n-\n-\t\tif (process.env.BOT_TEST == 'true') {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n-\t\t\t\t\tisSandbox: true,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t} else {\n-\t\t\tthis.accounts.setAccount(this.accountId, {\n-\t\t\t\t...overalAccountConf, ...{\n-\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n-\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n-\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n-\t\t\t\t\tisSandbox: false,\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n-\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n-\t}\n-\n-\n-\tasync trade() {\n-\t\t\n-\t\tlet\t\t\t\n-\t\t\tlastBid: number = 1,\n-\t\t\tlastStatUpdate = 0,\n-\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\n-\t\t\tawait this.prepare();\n-\n-\t\twhile (true) {\n-\n-\t\t\ttry {\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n-\t\t\t\t\tawait this.saveStat(this.accountId, this.accountConfig.currency1, this.accountConfig.currency2);\n-\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n-\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n-\t\t\t\t}\n-\n-\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.accountConfig.currency1, this.accountConfig.currency2);\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minBuyRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n-\t\t\t\t\tconst orders = await this.tryToBuy();\n-\t\t\t\t\tif (orders.length>0) {\n-\t\t\t\t\t\tawait this.checkCloseOrders();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n-\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n-\t\t\t\t\tawait this.tryToSellAllSuitableOrders();\n-\t\t\t\t\t\n-\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n-\t\t\t\t}\n-\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n-\t\t\t\tawait sleep(60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tasync tryToBuy() {\n-\t\tconst orders=[];\t\t\n-\t\tconst result=[];\n-\t\tconst accounts = await this.accountsReadyToBuy.get(this.accountConfig.orderAmount, this.config.minBuyRateMarginToProcess);\n-\t\tfor(const account of accounts) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createBuyOrder(\n-\t\t\t\t\taccount.accountId,\n-\t\t\t\t\taccount.currency1,\n-\t\t\t\t\taccount.currency2,\n-\t\t\t\t\taccount.rate,\n-\t\t\t\t\taccount.amount1\n-\t\t\t\t).then(order => {\n-\t\t\t\t\torders.push(order);\n-\t\t\t\t})\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(orders);\n-\n-\t\treturn orders;\n-\t}\n-\n-\t\n-\tpublic async tryToSellAllSuitableOrders(): Promise<Array<Order>> {\n-\n-\n-\t\tthis.log.info('Get active orders....');\n-\t\tconst tm = Date.now();\n-\t\tconst orders = await this.activeOrdersAboveProfit.get(\n-\t\t\tthis.accountConfig.minDailyProfit,\n-\t\t\tthis.accountConfig.minYearlyProfit\n-\t\t);\n-\n-\t\tthis.log.info('Ok...' + orders.length + ' orders ..' + ((Date.now() - tm) / 1000) + ' sec');\n-\n-\t\tconst result=[];\n-\t\tfor (const order of orders) {\n-\t\t\tresult.push(\n-\t\t\t\tthis.bot.createCloseOrder(order.buyRate, order)\n-\t\t\t);\n-\t\t}\n-\n-\t\tawait Promise.all(result);\n-\n-\t\treturn orders;\n-\t}\n-\n-\tprivate async prepare() {\n-\n-\t\tlet syncStatus = false;\n-\n-\t\twhile (!syncStatus) {\n-\t\t\ttry {\n-\n-\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n-\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n-\t\t\t\tawait this.checkBalance();\n-\n-\t\t\t\t// проверить состояние открытых ордеров\n-\t\t\t\tawait this.checkCloseOrders();\t\t\t\n-\n-\t\t\t\tsyncStatus = true;\n-\t\t\t} catch (e) {\n-\n-\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n-\t\t\t\tawait sleep(5 * 60);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n-\n-\t\tconst rateFrom = multiply(rate, (1-minMargin));\n-\t\tconst rateTo = multiply(rate, (1+minMargin));\n-\n-\t\tfor (const order of activeOrders) {\n-\t\t\tif (\n-\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n-\t\t\t\tcompareTo(order.rate, rateTo) < 0\n-\t\t\t) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t\t\n-\t}\n-\n-\tpublic async loadActiveOrders() {\n-\t\tthis.activeOrders = await this.orders.getActiveOrders();\n-\t\treturn this.activeOrders;\n-\t}\n-\n-\tprivate canBuy(accountId: any) {\n-\t\t// Пока это просто рандом\n-\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n-\t}\n-\n-\n-\tprivate async checkCloseOrders() {\n-\t\tconst closedOrders = await this.bot.checkCloseOrders();\n-\t\tif (closedOrders.length > 0) {\n-\n-\t\t\tawait this.checkBalance();\n-\n-\t\t}\n-\t}\n-\n-\tprivate async checkBalance() {\n-\t\tif (this.config.balanceSync)\n-\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n-\t}\n-\n-\n-\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n-\n-\t\tconst pair = currency1 + '/' + currency2;\n-\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n-\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n-\t\tconst rate = await this.api.getLastPrice(pair);\n-\n-\t\tthis.log.stat(\n-\t\t\tcurrency1,\n-\t\t\tbalance1,\n-\t\t\tcurrency2,\n-\t\t\tbalance2,\n-\t\t\t'Total in ' + currency2,\n-\t\t\tmultiply(rate, balance1)\n-\t\t);\n-\n-\n-\t}\n-\n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1691545811389,
            "name": "Commit-0",
            "content": "import { Inject, Injectable, Scope } from \"@nestjs/common\";\nimport { BotService } from \"./bot.service\";\nimport { FileLogService } from \"../log/filelog.service\";\nimport { SEC_IN_HOUR, elapsedSecondsFrom, sleep, isSuitableRate } from \"../helpers\";\nimport { PublicApiService } from \"../exchange/publicApi.service\";\nimport { AccountService } from \"../exchange/account.service\";\nimport { BalanceService } from \"../balance/balance.service\";\nimport { BalancesDto } from \"../balance/dto/balances.dto\";\nimport { OrderService } from \"../order/order.service\";\nimport { Order, OrderSideEnum } from \"../order/entities/order.entity\";\nimport { ApiService } from \"../exchange/api.service\";\nimport { PairService } from \"../exchange/pair.service\";\n\nconst { divide, subtract, multiply, compareTo, add } = require(\"js-big-decimal\");\n\n\ninterface Config {\n\tpair: string,\n\tcurrency1: string,\n\tcurrency2: string,\n\tminBuyRateMarginToProcess: number,\n\tminSellRateMarginToProcess: number,\n\tbalanceSync: boolean\n}\n\n@Injectable()\nexport class LonelyTraderService {\n\n\taccountId = 1;\n\tconfig: Config;\n\tapi:ApiService;\n\taccountConfig: { orderProbability: number; };\n\tactiveOrders:Array<Order>=[];\n\n\tconstructor(\n\n\t\tpublic bot: BotService,\n\t\tprivate log: FileLogService,\n\t\tprivate accounts: AccountService,\n\t\tprivate balance: BalanceService,\n\t\tprivate orders: OrderService,\n\t\tprivate pairs: PairService\n\n\t) {\n\n\t\tthis.config = {\n\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n\t\t\tminBuyRateMarginToProcess: Number(process.env.BOT_MIN_BUY_RATE_MARGIN), // минимальное движение курса для проверки х100=%\n\t\t\tminSellRateMarginToProcess: Number(process.env.BOT_MIN_SELL_RATE_MARGIN),\n\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n\t\t\tbalanceSync: process.env.BOT_BALANCE_SYNC == 'true'\n\t\t}\n\n\n\t\tconst overalAccountConf = {\n\t\t\tpair: process.env.BOT_CURRENCY1 + '/' + process.env.BOT_CURRENCY2,\n\t\t\torderAmount: Number(process.env.BOT_ORDER_AMOUNT),\n\t\t\tcurrency1: process.env.BOT_CURRENCY1,\n\t\t\tcurrency2: process.env.BOT_CURRENCY2,\n\t\t\torderProbability: Number(process.env.BOT_ORDER_PROBABILITY),\n\t\t};\n\n\t\tif (process.env.BOT_TEST == 'true') {\n\t\t\tthis.accounts.setAccount(this.accountId, {\n\t\t\t\t...overalAccountConf, ...{\n\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n\t\t\t\t\tapiKey: process.env.EXCHANGE_TESTNET_API_KEY,\n\t\t\t\t\tsecret: process.env.EXCHANGE_TESTNET_API_SECRET,\n\t\t\t\t\tisSandbox: true,\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tthis.accounts.setAccount(this.accountId, {\n\t\t\t\t...overalAccountConf, ...{\n\t\t\t\t\texchangeName: process.env.EXCHANGE_NAME,\n\t\t\t\t\tapiKey: process.env.EXCHANGE_API_KEY,\n\t\t\t\t\tsecret: process.env.EXCHANGE_API_SECRET,\n\t\t\t\t\tisSandbox: false,\n\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.bot.setConfig({\n\n\t\t\tminDailyProfit: Number(process.env.BOT_MIN_DAILY_PROFIT), // % годовых если сделка закрывается за день\n\t\t\tminYearlyProfit: Number(process.env.BOT_MIN_YERLY_PROFIT), // % годовых если сделка живет больше дня\t\t\t\n\t\t\tbuyFee: Number(process.env.BOT_BUY_FEE), //@todo вытаскивать как-то из биржи\n\t\t\tsellFee: Number(process.env.BOT_SELL_FEE),\n\t\t});\n\n\t\tthis.api = this.accounts.getApiForAccount(this.accountId);\n\t\tthis.accountConfig = this.accounts.getConfig(this.accountId);\n\t}\n\n\n\n\tasync trade() {\n\t\n\t\t\n\t\tlet\t\t\t\n\t\t\tlastBid: number = 1,\n\t\t\tlastStatUpdate = 0,\n\t\t\tlastTradesUpdate = Date.now() / 1000;\n\t\t\t\n\t\t\tawait this.prepare();\n\n\t\twhile (true) {\n\n\t\t\ttry {\n\n\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR, lastStatUpdate)) {\n\t\t\t\t\tawait this.saveStat(this.accountId, this.config.currency1, this.config.currency2);\n\t\t\t\t\tlastStatUpdate = Date.now() / 1000;\n\t\t\t\t}\n\n\t\t\t\tif (elapsedSecondsFrom(SEC_IN_HOUR / 4, lastTradesUpdate)) {\n\t\t\t\t\tawait this.checkCloseOrders();\n\t\t\t\t\tlastTradesUpdate = Date.now() / 1000;\n\t\t\t\t}\n\n\t\t\t\tconst { buyRate: rateBid, sellRate: rateAsk } = await this.pairs.getOrRefreshPair(this.config.currency1, this.config.currency2);\n\n\t\t\t\tif (!this.isRateOccupied(rateAsk, this.activeOrders, this.config.minBuyRateMarginToProcess)) {\n\t\t\t\t\tthis.log.info('Rate ask: ', rateAsk);\n\t\t\t\t\tconst result = await this.bot.tryToBuy(this.accountId, rateAsk)\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tconst {order} = result;\n\t\t\t\t\t\tthis.activeOrders.push(order);\n\n\t\t\t\t\t\tawait this.checkCloseOrders(); // need it because balance may have changed\n\n\t\t\t\t\t\tawait this.checkBalance();\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tif (isSuitableRate(rateBid, lastBid, this.config.minSellRateMarginToProcess)) {\n\t\t\t\t\tthis.log.info('Rate bid: ', rateBid);\n\t\t\t\t\tconst orders = await this.bot.tryToSellAllSuitableOrders();\n\t\t\t\t\tif (orders.length>0) {\n\t\t\t\t\t\tthis.loadActiveOrders();\n\t\t\t\t\t}\n\t\t\t\t\tlastBid = rateBid;\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\n\t\t\t\tthis.log.error('Trade error...wait 60 sec', e.message, e.stack);\n\t\t\t\tawait sleep(60);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async prepare() {\n\t\tlet syncStatus = false;\n\n\n\t\twhile (!syncStatus) {\n\t\t\ttry {\n\n\t\t\t\t// тут нужно загрузить в базу текущий баланс и в текущую переменную\n\t\t\t\tawait this.balance.loadBalancesAmount(this.accountId);\n\t\t\t\tawait this.checkBalance();\n\n\t\t\t\tawait this.bot.syncData(this.accountId);\n\n\t\t\t\t// проверить состояние открытых ордеров\n\t\t\t\tawait this.checkCloseOrders();\n\n\t\t\t\t// Загрузить открытые ордера\n\t\t\t\tawait this.loadActiveOrders();\n\t\t\t\t\n\n\t\t\t\tsyncStatus = true;\n\t\t\t} catch (e) {\n\n\t\t\t\tthis.log.error('Sync error...wait 5 min', e.message, e.stack);\n\t\t\t\tawait sleep(5 * 60);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic isRateOccupied(rate: number, activeOrders: Array<Order>, minMargin: number) {\n\n\t\tconst rateFrom = multiply(rate, (1-minMargin));\n\t\tconst rateTo = multiply(rate, (1+minMargin));\n\n\t\tfor (const order of activeOrders) {\n\t\t\tif (\n\t\t\t\tcompareTo(order.rate, rateFrom) > 0 && \n\t\t\t\tcompareTo(order.rate, rateTo) < 0\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\n\tpublic async loadActiveOrders() {\n\t\tthis.activeOrders = await this.orders.getActiveOrders();\n\t\treturn this.activeOrders;\n\t}\n\n\tprivate canBuy(accountId: any) {\n\t\t// Пока это просто рандом\n\t\treturn (Math.floor(Math.random() * 100) + 1) <= this.accountConfig.orderProbability;\n\t}\n\n\n\tprivate async checkCloseOrders() {\n\t\tconst closedOrders = await this.bot.checkCloseOrders();\n\t\tif (closedOrders.length > 0) {\n\n\t\t\tawait this.checkBalance();\n\n\t\t}\n\t}\n\n\tprivate async checkBalance() {\n\t\tif (this.config.balanceSync)\n\t\t\tawait this.balance.set(this.accountId, await this.api.fetchBalances());\n\t}\n\n\n\tprivate async saveStat(accountId: number, currency1: string, currency2: string) {\n\n\t\tconst pair = currency1 + '/' + currency2;\n\t\tconst balance1 = await this.balance.getBalanceAmount(accountId, currency1);\n\t\tconst balance2 = await this.balance.getBalanceAmount(accountId, currency2);\n\t\tconst rate = await this.api.getLastPrice(pair);\n\n\t\tthis.log.stat(\n\t\t\tcurrency1,\n\t\t\tbalance1,\n\t\t\tcurrency2,\n\t\t\tbalance2,\n\t\t\t'Total in ' + currency2,\n\t\t\tmultiply(rate, balance1)\n\t\t);\n\n\n\t}\n\n}"
        }
    ]
}