{
    "sourceFile": "src/exchange/api.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1691551991715,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1691552041954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n export class ApiService {\n \n     exchange;\n     lastTradesFetching;\n-    limits;\n+    limits={};\n \n \n     constructor(exchangeClass, apiKey: string='', secret: string='', sandBoxMode: boolean=true) {        \n         \n@@ -38,13 +38,18 @@\n         return {bid, ask};\n     }\n \n     public async getLimits(pair: string):Promise<{minAmount:number, minCost:number}> {\n+\n+        if (this.limits[pair]) {\n+            return this.limits[pair];\n+        }\n+\n         const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n         const {amount, cost} = markets[0].limits;\n+        this.limits[pair] = {minAmount:amount.min, minCost:cost.min};\n+        return this.limits[pair];\n \n-        return {minAmount:amount.min, minCost:cost.min};\n-\n     }\n \n     public async fetchBalances():Promise<BalancesDto> {\n \n"
                },
                {
                    "date": 1691559780260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n \n         return {bid, ask};\n     }\n \n-    public async getLimits(pair: string):Promise<{minAmount:number, minCost:number}> {\n+    public async getMarketInfo(pair: string):Promise<{minAmount:number, minCost:number}> {\n \n         if (this.limits[pair]) {\n             return this.limits[pair];\n         }\n"
                },
                {
                    "date": 1691559864244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,102 @@\n+import { OrderSide, OrderType } from \"ccxt/js/src/base/types\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderSideEnum } from \"../order/entities/order.entity\";\n+import {pro as ccxt} from \"ccxt\";\n+\n+\n+export class ApiService {\n+\n+    exchange;\n+    lastTradesFetching;\n+    markets={};\n+\n+\n+    constructor(exchangeClass, apiKey: string='', secret: string='', sandBoxMode: boolean=true) {        \n+        \n+        if (typeof exchangeClass == 'string') {\n+            exchangeClass = ccxt[exchangeClass];\n+        }\n+\n+        this.exchange = new exchangeClass({\n+            apiKey,\n+            secret\n+        });\n+        this.exchange.setSandboxMode(sandBoxMode);        \n+\n+    }\n+\n+    public async getActualRates(pair:string):Promise<{bid:number, ask:number}> {\n+        const orderBook = await this.exchange.fetchOrderBook(pair, 5);\n+\n+        if (orderBook.bids[0] == undefined || orderBook.asks[0] == undefined)  {            \n+            throw new Error('Can`t fetch rates');\n+        }\n+\n+        const bid = orderBook.bids[0][0];\n+        const ask = orderBook.asks[0][0];\n+\n+        return {bid, ask};\n+    }\n+\n+    public async getMarketInfo(pair: string):Promise<{minAmount:number, minCost:number}> {\n+\n+        if (this.markets[pair]) {\n+            return this.markets[pair];\n+        }\n+\n+        const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n+        const {amount, cost} = markets[0].limits;\n+        const {taker, maker}} = markets[0];\n+\n+        this.markets[pair] = {\n+            minAmount:amount.min, \n+            minCost:cost.min,\n+            fee: \n+        };\n+        return this.markets[pair];\n+\n+    }\n+\n+    public async fetchBalances():Promise<BalancesDto> {\n+\n+        // const markets = (await this.exchange.fetchMarkets()).filter((item) => item.id == 'ETHUSDT');\n+        // console.log(markets[0].limits, markets[0]);\n+        \n+\n+        const balances = (await this.exchange.fetchBalance()).info.balances;\n+        const result = {};\n+        balances.forEach((item)=>{\n+            result[item.asset] = item.free;\n+        });\n+\n+        return result;\n+    }\n+\n+    public async createOrder(symbol:string, type:OrderType, side:OrderSide, amount:number, price?:number) {\n+        return await this.exchange.createOrder(symbol, type, side, amount, price);\n+    }\n+\n+    public async watchTrades(pair: string) {      \n+\n+        return this.exchange.watchMyTrades(pair);\n+    }\n+\n+    public async fetchOrder(orderId:number, symbol: string) {\n+        return this.exchange.fetchOrder(String(orderId), symbol);\n+    }\n+\n+    public async fetchTickers() {\n+        return this.exchange.fetchTickers();\n+    }\n+\n+    public async fetchTrades(pair, since) {\n+        return this.exchange.fetchTrades(pair, since);\n+    }\n+\n+    async getLastPrice(pair) {\n+        const tickers = await this.fetchTickers();\n+        return tickers[pair].last;\n+    }\n+\n+}\n+\n"
                },
                {
                    "date": 1691559917686,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,11 @@\n         }\n \n         const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n         const {amount, cost} = markets[0].limits;\n-        const {taker, maker}} = markets[0];\n+        const {taker, maker} = markets[0];\n+        \n+        \n \n         this.markets[pair] = {\n             minAmount:amount.min, \n             minCost:cost.min,\n@@ -99,100 +101,4 @@\n     }\n \n }\n \n-import { OrderSide, OrderType } from \"ccxt/js/src/base/types\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderSideEnum } from \"../order/entities/order.entity\";\n-import {pro as ccxt} from \"ccxt\";\n-\n-\n-export class ApiService {\n-\n-    exchange;\n-    lastTradesFetching;\n-    limits={};\n-\n-\n-    constructor(exchangeClass, apiKey: string='', secret: string='', sandBoxMode: boolean=true) {        \n-        \n-        if (typeof exchangeClass == 'string') {\n-            exchangeClass = ccxt[exchangeClass];\n-        }\n-\n-        this.exchange = new exchangeClass({\n-            apiKey,\n-            secret\n-        });\n-        this.exchange.setSandboxMode(sandBoxMode);        \n-\n-    }\n-\n-    public async getActualRates(pair:string):Promise<{bid:number, ask:number}> {\n-        const orderBook = await this.exchange.fetchOrderBook(pair, 5);\n-\n-        if (orderBook.bids[0] == undefined || orderBook.asks[0] == undefined)  {            \n-            throw new Error('Can`t fetch rates');\n-        }\n-\n-        const bid = orderBook.bids[0][0];\n-        const ask = orderBook.asks[0][0];\n-\n-        return {bid, ask};\n-    }\n-\n-    public async getMarketInfo(pair: string):Promise<{minAmount:number, minCost:number}> {\n-\n-        if (this.limits[pair]) {\n-            return this.limits[pair];\n-        }\n-\n-        const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n-        const {amount, cost} = markets[0].limits;\n-        this.limits[pair] = {minAmount:amount.min, minCost:cost.min};\n-        return this.limits[pair];\n-\n-    }\n-\n-    public async fetchBalances():Promise<BalancesDto> {\n-\n-        // const markets = (await this.exchange.fetchMarkets()).filter((item) => item.id == 'ETHUSDT');\n-        // console.log(markets[0].limits, markets[0]);\n-        \n-\n-        const balances = (await this.exchange.fetchBalance()).info.balances;\n-        const result = {};\n-        balances.forEach((item)=>{\n-            result[item.asset] = item.free;\n-        });\n-\n-        return result;\n-    }\n-\n-    public async createOrder(symbol:string, type:OrderType, side:OrderSide, amount:number, price?:number) {\n-        return await this.exchange.createOrder(symbol, type, side, amount, price);\n-    }\n-\n-    public async watchTrades(pair: string) {      \n-\n-        return this.exchange.watchMyTrades(pair);\n-    }\n-\n-    public async fetchOrder(orderId:number, symbol: string) {\n-        return this.exchange.fetchOrder(String(orderId), symbol);\n-    }\n-\n-    public async fetchTickers() {\n-        return this.exchange.fetchTickers();\n-    }\n-\n-    public async fetchTrades(pair, since) {\n-        return this.exchange.fetchTrades(pair, since);\n-    }\n-\n-    async getLastPrice(pair) {\n-        const tickers = await this.fetchTickers();\n-        return tickers[pair].last;\n-    }\n-\n-}\n-\n"
                },
                {
                    "date": 1691559926259,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,104 @@\n+import { OrderSide, OrderType } from \"ccxt/js/src/base/types\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderSideEnum } from \"../order/entities/order.entity\";\n+import {pro as ccxt} from \"ccxt\";\n+\n+\n+export class ApiService {\n+\n+    exchange;\n+    lastTradesFetching;\n+    markets={};\n+\n+\n+    constructor(exchangeClass, apiKey: string='', secret: string='', sandBoxMode: boolean=true) {        \n+        \n+        if (typeof exchangeClass == 'string') {\n+            exchangeClass = ccxt[exchangeClass];\n+        }\n+\n+        this.exchange = new exchangeClass({\n+            apiKey,\n+            secret\n+        });\n+        this.exchange.setSandboxMode(sandBoxMode);        \n+\n+    }\n+\n+    public async getActualRates(pair:string):Promise<{bid:number, ask:number}> {\n+        const orderBook = await this.exchange.fetchOrderBook(pair, 5);\n+\n+        if (orderBook.bids[0] == undefined || orderBook.asks[0] == undefined)  {            \n+            throw new Error('Can`t fetch rates');\n+        }\n+\n+        const bid = orderBook.bids[0][0];\n+        const ask = orderBook.asks[0][0];\n+\n+        return {bid, ask};\n+    }\n+\n+    public async getMarketInfo(pair: string):Promise<{minAmount:number, minCost:number}> {\n+\n+        if (this.markets[pair]) {\n+            return this.markets[pair];\n+        }\n+\n+        const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n+        const {amount, cost} = markets[0].limits;\n+        const {taker, maker} = markets[0];\n+        \n+        \n+\n+        this.markets[pair] = {\n+            minAmount:amount.min, \n+            minCost:cost.min,\n+            fee: Math.max(taker, maker)\n+        };\n+        return this.markets[pair];\n+\n+    }\n+\n+    public async fetchBalances():Promise<BalancesDto> {\n+\n+        // const markets = (await this.exchange.fetchMarkets()).filter((item) => item.id == 'ETHUSDT');\n+        // console.log(markets[0].limits, markets[0]);\n+        \n+\n+        const balances = (await this.exchange.fetchBalance()).info.balances;\n+        const result = {};\n+        balances.forEach((item)=>{\n+            result[item.asset] = item.free;\n+        });\n+\n+        return result;\n+    }\n+\n+    public async createOrder(symbol:string, type:OrderType, side:OrderSide, amount:number, price?:number) {\n+        return await this.exchange.createOrder(symbol, type, side, amount, price);\n+    }\n+\n+    public async watchTrades(pair: string) {      \n+\n+        return this.exchange.watchMyTrades(pair);\n+    }\n+\n+    public async fetchOrder(orderId:number, symbol: string) {\n+        return this.exchange.fetchOrder(String(orderId), symbol);\n+    }\n+\n+    public async fetchTickers() {\n+        return this.exchange.fetchTickers();\n+    }\n+\n+    public async fetchTrades(pair, since) {\n+        return this.exchange.fetchTrades(pair, since);\n+    }\n+\n+    async getLastPrice(pair) {\n+        const tickers = await this.fetchTickers();\n+        return tickers[pair].last;\n+    }\n+\n+}\n+\n"
                },
                {
                    "date": 1691559989966,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,104 @@\n+import { OrderSide, OrderType } from \"ccxt/js/src/base/types\";\n+import { BalancesDto } from \"../balance/dto/balances.dto\";\n+import { OrderSideEnum } from \"../order/entities/order.entity\";\n+import {pro as ccxt} from \"ccxt\";\n+\n+\n+export class ApiService {\n+\n+    exchange;\n+    lastTradesFetching;\n+    markets={};\n+\n+\n+    constructor(exchangeClass, apiKey: string='', secret: string='', sandBoxMode: boolean=true) {        \n+        \n+        if (typeof exchangeClass == 'string') {\n+            exchangeClass = ccxt[exchangeClass];\n+        }\n+\n+        this.exchange = new exchangeClass({\n+            apiKey,\n+            secret\n+        });\n+        this.exchange.setSandboxMode(sandBoxMode);        \n+\n+    }\n+\n+    public async getActualRates(pair:string):Promise<{bid:number, ask:number}> {\n+        const orderBook = await this.exchange.fetchOrderBook(pair, 5);\n+\n+        if (orderBook.bids[0] == undefined || orderBook.asks[0] == undefined)  {            \n+            throw new Error('Can`t fetch rates');\n+        }\n+\n+        const bid = orderBook.bids[0][0];\n+        const ask = orderBook.asks[0][0];\n+\n+        return {bid, ask};\n+    }\n+\n+    public async getMarketInfo(pair: string):Promise<{minAmount:number, minCost:number, fee: number}> {\n+\n+        if (this.markets[pair]) {\n+            return this.markets[pair];\n+        }\n+\n+        const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n+        const {amount, cost} = markets[0].limits;\n+        const {taker, maker} = markets[0];\n+        \n+        \n+\n+        this.markets[pair] = {\n+            minAmount:amount.min, \n+            minCost:cost.min,\n+            fee: Math.max(taker, maker)\n+        };\n+        return this.markets[pair];\n+\n+    }\n+\n+    public async fetchBalances():Promise<BalancesDto> {\n+\n+        // const markets = (await this.exchange.fetchMarkets()).filter((item) => item.id == 'ETHUSDT');\n+        // console.log(markets[0].limits, markets[0]);\n+        \n+\n+        const balances = (await this.exchange.fetchBalance()).info.balances;\n+        const result = {};\n+        balances.forEach((item)=>{\n+            result[item.asset] = item.free;\n+        });\n+\n+        return result;\n+    }\n+\n+    public async createOrder(symbol:string, type:OrderType, side:OrderSide, amount:number, price?:number) {\n+        return await this.exchange.createOrder(symbol, type, side, amount, price);\n+    }\n+\n+    public async watchTrades(pair: string) {      \n+\n+        return this.exchange.watchMyTrades(pair);\n+    }\n+\n+    public async fetchOrder(orderId:number, symbol: string) {\n+        return this.exchange.fetchOrder(String(orderId), symbol);\n+    }\n+\n+    public async fetchTickers() {\n+        return this.exchange.fetchTickers();\n+    }\n+\n+    public async fetchTrades(pair, since) {\n+        return this.exchange.fetchTrades(pair, since);\n+    }\n+\n+    async getLastPrice(pair) {\n+        const tickers = await this.fetchTickers();\n+        return tickers[pair].last;\n+    }\n+\n+}\n+\n"
                },
                {
                    "date": 1691560008169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,11 +45,9 @@\n         }\n \n         const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n         const {amount, cost} = markets[0].limits;\n-        const {taker, maker} = markets[0];\n-        \n-        \n+        const {taker, maker} = markets[0];       \n \n         this.markets[pair] = {\n             minAmount:amount.min, \n             minCost:cost.min,\n@@ -101,212 +99,4 @@\n     }\n \n }\n \n-import { OrderSide, OrderType } from \"ccxt/js/src/base/types\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderSideEnum } from \"../order/entities/order.entity\";\n-import {pro as ccxt} from \"ccxt\";\n-\n-\n-export class ApiService {\n-\n-    exchange;\n-    lastTradesFetching;\n-    markets={};\n-\n-\n-    constructor(exchangeClass, apiKey: string='', secret: string='', sandBoxMode: boolean=true) {        \n-        \n-        if (typeof exchangeClass == 'string') {\n-            exchangeClass = ccxt[exchangeClass];\n-        }\n-\n-        this.exchange = new exchangeClass({\n-            apiKey,\n-            secret\n-        });\n-        this.exchange.setSandboxMode(sandBoxMode);        \n-\n-    }\n-\n-    public async getActualRates(pair:string):Promise<{bid:number, ask:number}> {\n-        const orderBook = await this.exchange.fetchOrderBook(pair, 5);\n-\n-        if (orderBook.bids[0] == undefined || orderBook.asks[0] == undefined)  {            \n-            throw new Error('Can`t fetch rates');\n-        }\n-\n-        const bid = orderBook.bids[0][0];\n-        const ask = orderBook.asks[0][0];\n-\n-        return {bid, ask};\n-    }\n-\n-    public async getMarketInfo(pair: string):Promise<{minAmount:number, minCost:number}> {\n-\n-        if (this.markets[pair]) {\n-            return this.markets[pair];\n-        }\n-\n-        const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n-        const {amount, cost} = markets[0].limits;\n-        const {taker, maker} = markets[0];\n-        \n-        \n-\n-        this.markets[pair] = {\n-            minAmount:amount.min, \n-            minCost:cost.min,\n-            fee: Math.max(taker, maker)\n-        };\n-        return this.markets[pair];\n-\n-    }\n-\n-    public async fetchBalances():Promise<BalancesDto> {\n-\n-        // const markets = (await this.exchange.fetchMarkets()).filter((item) => item.id == 'ETHUSDT');\n-        // console.log(markets[0].limits, markets[0]);\n-        \n-\n-        const balances = (await this.exchange.fetchBalance()).info.balances;\n-        const result = {};\n-        balances.forEach((item)=>{\n-            result[item.asset] = item.free;\n-        });\n-\n-        return result;\n-    }\n-\n-    public async createOrder(symbol:string, type:OrderType, side:OrderSide, amount:number, price?:number) {\n-        return await this.exchange.createOrder(symbol, type, side, amount, price);\n-    }\n-\n-    public async watchTrades(pair: string) {      \n-\n-        return this.exchange.watchMyTrades(pair);\n-    }\n-\n-    public async fetchOrder(orderId:number, symbol: string) {\n-        return this.exchange.fetchOrder(String(orderId), symbol);\n-    }\n-\n-    public async fetchTickers() {\n-        return this.exchange.fetchTickers();\n-    }\n-\n-    public async fetchTrades(pair, since) {\n-        return this.exchange.fetchTrades(pair, since);\n-    }\n-\n-    async getLastPrice(pair) {\n-        const tickers = await this.fetchTickers();\n-        return tickers[pair].last;\n-    }\n-\n-}\n-\n-import { OrderSide, OrderType } from \"ccxt/js/src/base/types\";\n-import { BalancesDto } from \"../balance/dto/balances.dto\";\n-import { OrderSideEnum } from \"../order/entities/order.entity\";\n-import {pro as ccxt} from \"ccxt\";\n-\n-\n-export class ApiService {\n-\n-    exchange;\n-    lastTradesFetching;\n-    markets={};\n-\n-\n-    constructor(exchangeClass, apiKey: string='', secret: string='', sandBoxMode: boolean=true) {        \n-        \n-        if (typeof exchangeClass == 'string') {\n-            exchangeClass = ccxt[exchangeClass];\n-        }\n-\n-        this.exchange = new exchangeClass({\n-            apiKey,\n-            secret\n-        });\n-        this.exchange.setSandboxMode(sandBoxMode);        \n-\n-    }\n-\n-    public async getActualRates(pair:string):Promise<{bid:number, ask:number}> {\n-        const orderBook = await this.exchange.fetchOrderBook(pair, 5);\n-\n-        if (orderBook.bids[0] == undefined || orderBook.asks[0] == undefined)  {            \n-            throw new Error('Can`t fetch rates');\n-        }\n-\n-        const bid = orderBook.bids[0][0];\n-        const ask = orderBook.asks[0][0];\n-\n-        return {bid, ask};\n-    }\n-\n-    public async getMarketInfo(pair: string):Promise<{minAmount:number, minCost:number}> {\n-\n-        if (this.markets[pair]) {\n-            return this.markets[pair];\n-        }\n-\n-        const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n-        const {amount, cost} = markets[0].limits;\n-        const {taker, maker} = markets[0];\n-        \n-        \n-\n-        this.markets[pair] = {\n-            minAmount:amount.min, \n-            minCost:cost.min,\n-            fee: \n-        };\n-        return this.markets[pair];\n-\n-    }\n-\n-    public async fetchBalances():Promise<BalancesDto> {\n-\n-        // const markets = (await this.exchange.fetchMarkets()).filter((item) => item.id == 'ETHUSDT');\n-        // console.log(markets[0].limits, markets[0]);\n-        \n-\n-        const balances = (await this.exchange.fetchBalance()).info.balances;\n-        const result = {};\n-        balances.forEach((item)=>{\n-            result[item.asset] = item.free;\n-        });\n-\n-        return result;\n-    }\n-\n-    public async createOrder(symbol:string, type:OrderType, side:OrderSide, amount:number, price?:number) {\n-        return await this.exchange.createOrder(symbol, type, side, amount, price);\n-    }\n-\n-    public async watchTrades(pair: string) {      \n-\n-        return this.exchange.watchMyTrades(pair);\n-    }\n-\n-    public async fetchOrder(orderId:number, symbol: string) {\n-        return this.exchange.fetchOrder(String(orderId), symbol);\n-    }\n-\n-    public async fetchTickers() {\n-        return this.exchange.fetchTickers();\n-    }\n-\n-    public async fetchTrades(pair, since) {\n-        return this.exchange.fetchTrades(pair, since);\n-    }\n-\n-    async getLastPrice(pair) {\n-        const tickers = await this.fetchTickers();\n-        return tickers[pair].last;\n-    }\n-\n-}\n-\n"
                }
            ],
            "date": 1691551991715,
            "name": "Commit-0",
            "content": "import { OrderSide, OrderType } from \"ccxt/js/src/base/types\";\nimport { BalancesDto } from \"../balance/dto/balances.dto\";\nimport { OrderSideEnum } from \"../order/entities/order.entity\";\nimport {pro as ccxt} from \"ccxt\";\n\n\nexport class ApiService {\n\n    exchange;\n    lastTradesFetching;\n    limits;\n\n\n    constructor(exchangeClass, apiKey: string='', secret: string='', sandBoxMode: boolean=true) {        \n        \n        if (typeof exchangeClass == 'string') {\n            exchangeClass = ccxt[exchangeClass];\n        }\n\n        this.exchange = new exchangeClass({\n            apiKey,\n            secret\n        });\n        this.exchange.setSandboxMode(sandBoxMode);        \n\n    }\n\n    public async getActualRates(pair:string):Promise<{bid:number, ask:number}> {\n        const orderBook = await this.exchange.fetchOrderBook(pair, 5);\n\n        if (orderBook.bids[0] == undefined || orderBook.asks[0] == undefined)  {            \n            throw new Error('Can`t fetch rates');\n        }\n\n        const bid = orderBook.bids[0][0];\n        const ask = orderBook.asks[0][0];\n\n        return {bid, ask};\n    }\n\n    public async getLimits(pair: string):Promise<{minAmount:number, minCost:number}> {\n        const markets = (await this.exchange.fetchMarkets()).filter((item) => item.symbol == pair);\n        const {amount, cost} = markets[0].limits;\n\n        return {minAmount:amount.min, minCost:cost.min};\n\n    }\n\n    public async fetchBalances():Promise<BalancesDto> {\n\n        // const markets = (await this.exchange.fetchMarkets()).filter((item) => item.id == 'ETHUSDT');\n        // console.log(markets[0].limits, markets[0]);\n        \n\n        const balances = (await this.exchange.fetchBalance()).info.balances;\n        const result = {};\n        balances.forEach((item)=>{\n            result[item.asset] = item.free;\n        });\n\n        return result;\n    }\n\n    public async createOrder(symbol:string, type:OrderType, side:OrderSide, amount:number, price?:number) {\n        return await this.exchange.createOrder(symbol, type, side, amount, price);\n    }\n\n    public async watchTrades(pair: string) {      \n\n        return this.exchange.watchMyTrades(pair);\n    }\n\n    public async fetchOrder(orderId:number, symbol: string) {\n        return this.exchange.fetchOrder(String(orderId), symbol);\n    }\n\n    public async fetchTickers() {\n        return this.exchange.fetchTickers();\n    }\n\n    public async fetchTrades(pair, since) {\n        return this.exchange.fetchTrades(pair, since);\n    }\n\n    async getLastPrice(pair) {\n        const tickers = await this.fetchTickers();\n        return tickers[pair].last;\n    }\n\n}\n\n"
        }
    ]
}