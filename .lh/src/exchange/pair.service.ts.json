{
    "sourceFile": "src/exchange/pair.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 15,
            "patches": [
                {
                    "date": 1691551883907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1691551929935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,89 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { checkLimits, elapsedSecondsFrom, lock } from \"../helpers\";\n+import { PublicApiService } from \"./publicApi.service\";\n+import { InjectRepository } from \"@nestjs/typeorm\";\n+import { Pair } from \"./entities/pair.entity\";\n+import { Repository } from \"typeorm\";\n+\n+@Injectable()\n+export class PairService  {\n+\n+  pairs:{ [id: string]: Pair }={};\n+  lastRequestTime={};  \n+  FETCH_TIMEOUT;\n+  minAmount;\n+  minCost;\n+\n+  constructor(\n+    public publicApi: PublicApiService,\n+    @InjectRepository(Pair)\n+    private pairRepository: Repository<Pair>\n+  ) {    \n+    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n+    \n+  }\n+\n+  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n+    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n+    if (!pair) {\n+      pair = this.pairRepository.create({currency1, currency2})\n+      await this.pairRepository.save(\n+        pair\n+      );\n+      const pairTitle = currency1 + '/' + currency2;\n+      this.lastRequestTime[pairTitle] = 1;\n+    }\n+    return pair;\n+  }\n+\n+  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n+\n+    const pair = currency1 + '/' + currency2;\n+    if (!this.pairs[pair]) {\n+      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n+    }\n+\n+    if (!this.lastRequestTime[pair]) {\n+      this.lastRequestTime[pair] = 1;\n+    }\n+\n+\n+    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n+\n+      await lock.acquire('requestLastPair ' + pair, async () => {\n+\n+        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n+          return this.pairs[pair];\n+        }\n+\n+        this.lastRequestTime[pair] = Date.now()/1000;\n+        await this.refreshPairInfo(currency1, currency2);\n+\n+      });\n+\n+    }\n+\n+    return this.pairs[pair];\n+  }\n+\n+  public async refreshPairInfo(currency1: string, currency2: string) {\n+    const pair = currency1 + '/' + currency2;\n+\n+    const lastPrice = await this.publicApi.getLastPrice(pair);\n+    const {bid, ask} = await this.publicApi.getActualRates(pair);\n+\n+    this.pairs[pair].lastPrice = lastPrice;\n+    this.pairs[pair].buyRate = bid;\n+    this.pairs[pair].sellRate = ask;\n+\n+    ({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(pair));\n+    const amount1: number = checkLimits(ask);\n+\n+    await this.pairRepository.save(\n+      this.pairs[pair]\n+    );\n+\n+    return this.pairs[pair];\n+  }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691551953731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,103 +75,15 @@\n     this.pairs[pair].lastPrice = lastPrice;\n     this.pairs[pair].buyRate = bid;\n     this.pairs[pair].sellRate = ask;\n \n-    ({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(pair));\n-    const amount1: number = checkLimits(ask);\n+    const { minAmount, minCost } = await this.publicApi.getLimits(pair);\n+    const amount1: number = checkLimits(minAmount, minCost, ask);\n \n     await this.pairRepository.save(\n       this.pairs[pair]\n     );\n \n     return this.pairs[pair];\n   }\n \n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { checkLimits, elapsedSecondsFrom, lock } from \"../helpers\";\n-import { PublicApiService } from \"./publicApi.service\";\n-import { InjectRepository } from \"@nestjs/typeorm\";\n-import { Pair } from \"./entities/pair.entity\";\n-import { Repository } from \"typeorm\";\n-\n-@Injectable()\n-export class PairService  {\n-\n-  pairs:{ [id: string]: Pair }={};\n-  lastRequestTime={};  \n-  FETCH_TIMEOUT;\n-  minAmount;\n-  minCost;\n-\n-  constructor(\n-    public publicApi: PublicApiService,\n-    @InjectRepository(Pair)\n-    private pairRepository: Repository<Pair>\n-  ) {    \n-    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n-    ({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n-  }\n-\n-  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n-    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n-    if (!pair) {\n-      pair = this.pairRepository.create({currency1, currency2})\n-      await this.pairRepository.save(\n-        pair\n-      );\n-      const pairTitle = currency1 + '/' + currency2;\n-      this.lastRequestTime[pairTitle] = 1;\n-    }\n-    return pair;\n-  }\n-\n-  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n-\n-    const pair = currency1 + '/' + currency2;\n-    if (!this.pairs[pair]) {\n-      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n-    }\n-\n-    if (!this.lastRequestTime[pair]) {\n-      this.lastRequestTime[pair] = 1;\n-    }\n-\n-\n-    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n-\n-      await lock.acquire('requestLastPair ' + pair, async () => {\n-\n-        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n-          return this.pairs[pair];\n-        }\n-\n-        this.lastRequestTime[pair] = Date.now()/1000;\n-        await this.refreshPairInfo(currency1, currency2);\n-\n-      });\n-\n-    }\n-\n-    return this.pairs[pair];\n-  }\n-\n-  public async refreshPairInfo(currency1: string, currency2: string) {\n-    const pair = currency1 + '/' + currency2;\n-\n-    const lastPrice = await this.publicApi.getLastPrice(pair);\n-    const {bid, ask} = await this.publicApi.getActualRates(pair);\n-\n-    this.pairs[pair].lastPrice = lastPrice;\n-    this.pairs[pair].buyRate = bid;\n-    this.pairs[pair].sellRate = ask;\n-\n-    const amount1: number = checkLimits(ask);\n-\n-    await this.pairRepository.save(\n-      this.pairs[pair]\n-    );\n-\n-    return this.pairs[pair];\n-  }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691551969385,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,11 @@\n   minAmount;\n   minCost;\n \n   constructor(\n+    \n     public publicApi: PublicApiService,\n+\n     @InjectRepository(Pair)\n     private pairRepository: Repository<Pair>\n   ) {    \n     this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n"
                },
                {
                    "date": 1691552095037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,9 @@\n     this.pairs[pair].buyRate = bid;\n     this.pairs[pair].sellRate = ask;\n \n     const { minAmount, minCost } = await this.publicApi.getLimits(pair);\n-    const amount1: number = checkLimits(minAmount, minCost, ask);\n+    this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n \n     await this.pairRepository.save(\n       this.pairs[pair]\n     );\n"
                },
                {
                    "date": 1691555424467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,8 +79,9 @@\n     this.pairs[pair].sellRate = ask;\n \n     const { minAmount, minCost } = await this.publicApi.getLimits(pair);\n     this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n+    this.pairs[pair].minAmount2 = minCost;\n \n     await this.pairRepository.save(\n       this.pairs[pair]\n     );\n"
                },
                {
                    "date": 1691559780268,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n     this.pairs[pair].lastPrice = lastPrice;\n     this.pairs[pair].buyRate = bid;\n     this.pairs[pair].sellRate = ask;\n \n-    const { minAmount, minCost } = await this.publicApi.getLimits(pair);\n+    const { minAmount, minCost } = await this.publicApi.getMarketInfo(pair);\n     this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n     this.pairs[pair].minAmount2 = minCost;\n \n     await this.pairRepository.save(\n"
                },
                {
                    "date": 1691559976057,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,93 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { checkLimits, elapsedSecondsFrom, lock } from \"../helpers\";\n+import { PublicApiService } from \"./publicApi.service\";\n+import { InjectRepository } from \"@nestjs/typeorm\";\n+import { Pair } from \"./entities/pair.entity\";\n+import { Repository } from \"typeorm\";\n+\n+@Injectable()\n+export class PairService  {\n+\n+  pairs:{ [id: string]: Pair }={};\n+  lastRequestTime={};  \n+  FETCH_TIMEOUT;\n+  minAmount;\n+  minCost;\n+\n+  constructor(\n+    \n+    public publicApi: PublicApiService,\n+\n+    @InjectRepository(Pair)\n+    private pairRepository: Repository<Pair>\n+  ) {    \n+    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n+    \n+  }\n+\n+  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n+    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n+    if (!pair) {\n+      pair = this.pairRepository.create({currency1, currency2})\n+      await this.pairRepository.save(\n+        pair\n+      );\n+      const pairTitle = currency1 + '/' + currency2;\n+      this.lastRequestTime[pairTitle] = 1;\n+    }\n+    return pair;\n+  }\n+\n+  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n+\n+    const pair = currency1 + '/' + currency2;\n+    if (!this.pairs[pair]) {\n+      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n+    }\n+\n+    if (!this.lastRequestTime[pair]) {\n+      this.lastRequestTime[pair] = 1;\n+    }\n+\n+\n+    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n+\n+      await lock.acquire('requestLastPair ' + pair, async () => {\n+\n+        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n+          return this.pairs[pair];\n+        }\n+\n+        this.lastRequestTime[pair] = Date.now()/1000;\n+        await this.refreshPairInfo(currency1, currency2);\n+\n+      });\n+\n+    }\n+\n+    return this.pairs[pair];\n+  }\n+\n+  public async refreshPairInfo(currency1: string, currency2: string) {\n+    const pair = currency1 + '/' + currency2;\n+\n+    const lastPrice = await this.publicApi.getLastPrice(pair);\n+    const {bid, ask} = await this.publicApi.getActualRates(pair);\n+\n+    this.pairs[pair].lastPrice = lastPrice;\n+    this.pairs[pair].buyRate = bid;\n+    this.pairs[pair].sellRate = ask;\n+\n+    const { minAmount, minCost, fee } = await this.publicApi.getMarketInfo(pair);\n+    this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n+    this.pairs[pair].minAmount2 = minCost;\n+    this.pairs[pair].fee = fee;\n+\n+    await this.pairRepository.save(\n+      this.pairs[pair]\n+    );\n+\n+    return this.pairs[pair];\n+  }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691636453044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,97 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { checkLimits, elapsedSecondsFrom, lock, updateModel } from \"../helpers\";\n+import { PublicApiService } from \"./publicApi.service\";\n+import { InjectRepository } from \"@nestjs/typeorm\";\n+import { Pair } from \"./entities/pair.entity\";\n+import { Repository } from \"typeorm\";\n+\n+@Injectable()\n+export class PairService  {\n+\n+  pairs:{ [id: string]: Pair }={};\n+  lastRequestTime={};  \n+  FETCH_TIMEOUT;\n+  minAmount;\n+  minCost;\n+\n+  constructor(\n+    \n+    public publicApi: PublicApiService,\n+\n+    @InjectRepository(Pair)\n+    private pairRepository: Repository<Pair>\n+  ) {    \n+    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n+    \n+  }\n+\n+  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n+    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n+    if (!pair) {\n+      pair = this.pairRepository.create({currency1, currency2})\n+      await this.pairRepository.save(\n+        pair\n+      );\n+      const pairTitle = currency1 + '/' + currency2;\n+      this.lastRequestTime[pairTitle] = 1;\n+    }\n+    return pair;\n+  }\n+\n+  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n+\n+    const pair = currency1 + '/' + currency2;\n+    if (!this.pairs[pair]) {\n+      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n+    }\n+\n+    if (!this.lastRequestTime[pair]) {\n+      this.lastRequestTime[pair] = 1;\n+    }\n+\n+\n+    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n+\n+      await lock.acquire('requestLastPair ' + pair, async () => {\n+\n+        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n+          return this.pairs[pair];\n+        }\n+\n+        this.lastRequestTime[pair] = Date.now()/1000;\n+        await this.refreshPairInfo(currency1, currency2);\n+\n+      });\n+\n+    }\n+\n+    return this.pairs[pair];\n+  }\n+\n+  setInfo(pair, data) {\n+    updateModel(this.pairs[pair], data);\n+  }\n+\n+  public async refreshPairInfo(currency1: string, currency2: string) {\n+    const pair = currency1 + '/' + currency2;\n+\n+    const lastPrice = await this.publicApi.getLastPrice(pair);\n+    const {bid, ask} = await this.publicApi.getActualRates(pair);\n+\n+    this.pairs[pair].lastPrice = lastPrice;\n+    this.pairs[pair].buyRate = bid;\n+    this.pairs[pair].sellRate = ask;\n+\n+    const { minAmount, minCost, fee } = await this.publicApi.getMarketInfo(pair);\n+    this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n+    this.pairs[pair].minAmount2 = minCost;\n+    this.pairs[pair].fee = fee;\n+\n+    await this.pairRepository.save(\n+      this.pairs[pair]\n+    );\n+\n+    return this.pairs[pair];\n+  }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691636462058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,98 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { checkLimits, elapsedSecondsFrom, lock, updateModel } from \"../helpers\";\n+import { PublicApiService } from \"./publicApi.service\";\n+import { InjectRepository } from \"@nestjs/typeorm\";\n+import { Pair } from \"./entities/pair.entity\";\n+import { Repository } from \"typeorm\";\n+\n+@Injectable()\n+export class PairService  {\n+\n+  pairs:{ [id: string]: Pair }={};\n+  lastRequestTime={};  \n+  FETCH_TIMEOUT;\n+  minAmount;\n+  minCost;\n+\n+  constructor(\n+    \n+    public publicApi: PublicApiService,\n+\n+    @InjectRepository(Pair)\n+    private pairRepository: Repository<Pair>\n+  ) {    \n+    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n+    \n+  }\n+\n+  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n+    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n+    if (!pair) {\n+      pair = this.pairRepository.create({currency1, currency2})\n+      await this.pairRepository.save(\n+        pair\n+      );\n+      const pairTitle = currency1 + '/' + currency2;\n+      this.lastRequestTime[pairTitle] = 1;\n+    }\n+    return pair;\n+  }\n+\n+  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n+\n+    const pair = currency1 + '/' + currency2;\n+    if (!this.pairs[pair]) {\n+      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n+    }\n+\n+    if (!this.lastRequestTime[pair]) {\n+      this.lastRequestTime[pair] = 1;\n+    }\n+\n+\n+    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n+\n+      await lock.acquire('requestLastPair ' + pair, async () => {\n+\n+        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n+          return this.pairs[pair];\n+        }\n+\n+        this.lastRequestTime[pair] = Date.now()/1000;\n+        await this.refreshPairInfo(currency1, currency2);\n+\n+      });\n+\n+    }\n+\n+    return this.pairs[pair];\n+  }\n+\n+  setInfo(pair, data) {\n+    updateModel(this.pairs[pair], data);\n+  }\n+\n+  public async refreshPairInfo(currency1: string, currency2: string) {\n+    const pair = currency1 + '/' + currency2;\n+\n+    const lastPrice = await this.publicApi.getLastPrice(pair);\n+    const {bid, ask} = await this.publicApi.getActualRates(pair);\n+    const { minAmount, minCost, fee } = await this.publicApi.getMarketInfo(pair);\n+    \n+    this.pairs[pair].lastPrice = lastPrice;\n+    this.pairs[pair].buyRate = bid;\n+    this.pairs[pair].sellRate = ask;\n+\n+    \n+    this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n+    this.pairs[pair].minAmount2 = minCost;\n+    this.pairs[pair].fee = fee;\n+\n+    await this.pairRepository.save(\n+      this.pairs[pair]\n+    );\n+\n+    return this.pairs[pair];\n+  }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691636568917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,312 +69,29 @@\n   }\n \n   setInfo(pair, data) {\n     updateModel(this.pairs[pair], data);\n-  }\n-\n-  public async refreshPairInfo(currency1: string, currency2: string) {\n-    const pair = currency1 + '/' + currency2;\n-\n-    const lastPrice = await this.publicApi.getLastPrice(pair);\n-    const {bid, ask} = await this.publicApi.getActualRates(pair);\n-    const { minAmount, minCost, fee } = await this.publicApi.getMarketInfo(pair);\n     \n-    this.pairs[pair].lastPrice = lastPrice;\n-    this.pairs[pair].buyRate = bid;\n-    this.pairs[pair].sellRate = ask;\n-\n-    \n-    this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n-    this.pairs[pair].minAmount2 = minCost;\n-    this.pairs[pair].fee = fee;\n-\n     await this.pairRepository.save(\n       this.pairs[pair]\n     );\n-\n-    return this.pairs[pair];\n   }\n \n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { checkLimits, elapsedSecondsFrom, lock, updateModel } from \"../helpers\";\n-import { PublicApiService } from \"./publicApi.service\";\n-import { InjectRepository } from \"@nestjs/typeorm\";\n-import { Pair } from \"./entities/pair.entity\";\n-import { Repository } from \"typeorm\";\n-\n-@Injectable()\n-export class PairService  {\n-\n-  pairs:{ [id: string]: Pair }={};\n-  lastRequestTime={};  \n-  FETCH_TIMEOUT;\n-  minAmount;\n-  minCost;\n-\n-  constructor(\n-    \n-    public publicApi: PublicApiService,\n-\n-    @InjectRepository(Pair)\n-    private pairRepository: Repository<Pair>\n-  ) {    \n-    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n-    \n-  }\n-\n-  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n-    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n-    if (!pair) {\n-      pair = this.pairRepository.create({currency1, currency2})\n-      await this.pairRepository.save(\n-        pair\n-      );\n-      const pairTitle = currency1 + '/' + currency2;\n-      this.lastRequestTime[pairTitle] = 1;\n-    }\n-    return pair;\n-  }\n-\n-  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n-\n-    const pair = currency1 + '/' + currency2;\n-    if (!this.pairs[pair]) {\n-      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n-    }\n-\n-    if (!this.lastRequestTime[pair]) {\n-      this.lastRequestTime[pair] = 1;\n-    }\n-\n-\n-    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n-\n-      await lock.acquire('requestLastPair ' + pair, async () => {\n-\n-        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n-          return this.pairs[pair];\n-        }\n-\n-        this.lastRequestTime[pair] = Date.now()/1000;\n-        await this.refreshPairInfo(currency1, currency2);\n-\n-      });\n-\n-    }\n-\n-    return this.pairs[pair];\n-  }\n-\n-  setInfo(pair, data) {\n-    updateModel(this.pairs[pair], data);\n-  }\n-\n   public async refreshPairInfo(currency1: string, currency2: string) {\n     const pair = currency1 + '/' + currency2;\n \n     const lastPrice = await this.publicApi.getLastPrice(pair);\n     const {bid, ask} = await this.publicApi.getActualRates(pair);\n-\n-    this.pairs[pair].lastPrice = lastPrice;\n-    this.pairs[pair].buyRate = bid;\n-    this.pairs[pair].sellRate = ask;\n-\n     const { minAmount, minCost, fee } = await this.publicApi.getMarketInfo(pair);\n-    this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n-    this.pairs[pair].minAmount2 = minCost;\n-    this.pairs[pair].fee = fee;\n \n-    await this.pairRepository.save(\n-      this.pairs[pair]\n-    );\n-\n-    return this.pairs[pair];\n-  }\n-\n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { checkLimits, elapsedSecondsFrom, lock } from \"../helpers\";\n-import { PublicApiService } from \"./publicApi.service\";\n-import { InjectRepository } from \"@nestjs/typeorm\";\n-import { Pair } from \"./entities/pair.entity\";\n-import { Repository } from \"typeorm\";\n-\n-@Injectable()\n-export class PairService  {\n-\n-  pairs:{ [id: string]: Pair }={};\n-  lastRequestTime={};  \n-  FETCH_TIMEOUT;\n-  minAmount;\n-  minCost;\n-\n-  constructor(\n-    \n-    public publicApi: PublicApiService,\n-\n-    @InjectRepository(Pair)\n-    private pairRepository: Repository<Pair>\n-  ) {    \n-    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n-    \n-  }\n-\n-  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n-    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n-    if (!pair) {\n-      pair = this.pairRepository.create({currency1, currency2})\n-      await this.pairRepository.save(\n-        pair\n-      );\n-      const pairTitle = currency1 + '/' + currency2;\n-      this.lastRequestTime[pairTitle] = 1;\n-    }\n-    return pair;\n-  }\n-\n-  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n-\n-    const pair = currency1 + '/' + currency2;\n-    if (!this.pairs[pair]) {\n-      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n-    }\n-\n-    if (!this.lastRequestTime[pair]) {\n-      this.lastRequestTime[pair] = 1;\n-    }\n-\n-\n-    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n-\n-      await lock.acquire('requestLastPair ' + pair, async () => {\n-\n-        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n-          return this.pairs[pair];\n-        }\n-\n-        this.lastRequestTime[pair] = Date.now()/1000;\n-        await this.refreshPairInfo(currency1, currency2);\n-\n-      });\n-\n-    }\n-\n-    return this.pairs[pair];\n-  }\n-\n-  public async refreshPairInfo(currency1: string, currency2: string) {\n-    const pair = currency1 + '/' + currency2;\n-\n-    const lastPrice = await this.publicApi.getLastPrice(pair);\n-    const {bid, ask} = await this.publicApi.getActualRates(pair);\n-\n     this.pairs[pair].lastPrice = lastPrice;\n     this.pairs[pair].buyRate = bid;\n-    this.pairs[pair].sellRate = ask;\n-\n-    const { minAmount, minCost, fee } = await this.publicApi.getMarketInfo(pair);\n+    this.pairs[pair].sellRate = ask;    \n     this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n     this.pairs[pair].minAmount2 = minCost;\n     this.pairs[pair].fee = fee;\n \n-    await this.pairRepository.save(\n-      this.pairs[pair]\n-    );\n \n     return this.pairs[pair];\n   }\n \n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { checkLimits, elapsedSecondsFrom, lock } from \"../helpers\";\n-import { PublicApiService } from \"./publicApi.service\";\n-import { InjectRepository } from \"@nestjs/typeorm\";\n-import { Pair } from \"./entities/pair.entity\";\n-import { Repository } from \"typeorm\";\n-\n-@Injectable()\n-export class PairService  {\n-\n-  pairs:{ [id: string]: Pair }={};\n-  lastRequestTime={};  \n-  FETCH_TIMEOUT;\n-  minAmount;\n-  minCost;\n-\n-  constructor(\n-    \n-    public publicApi: PublicApiService,\n-\n-    @InjectRepository(Pair)\n-    private pairRepository: Repository<Pair>\n-  ) {    \n-    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n-    \n-  }\n-\n-  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n-    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n-    if (!pair) {\n-      pair = this.pairRepository.create({currency1, currency2})\n-      await this.pairRepository.save(\n-        pair\n-      );\n-      const pairTitle = currency1 + '/' + currency2;\n-      this.lastRequestTime[pairTitle] = 1;\n-    }\n-    return pair;\n-  }\n-\n-  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n-\n-    const pair = currency1 + '/' + currency2;\n-    if (!this.pairs[pair]) {\n-      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n-    }\n-\n-    if (!this.lastRequestTime[pair]) {\n-      this.lastRequestTime[pair] = 1;\n-    }\n-\n-\n-    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n-\n-      await lock.acquire('requestLastPair ' + pair, async () => {\n-\n-        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n-          return this.pairs[pair];\n-        }\n-\n-        this.lastRequestTime[pair] = Date.now()/1000;\n-        await this.refreshPairInfo(currency1, currency2);\n-\n-      });\n-\n-    }\n-\n-    return this.pairs[pair];\n-  }\n-\n-  public async refreshPairInfo(currency1: string, currency2: string) {\n-    const pair = currency1 + '/' + currency2;\n-\n-    const lastPrice = await this.publicApi.getLastPrice(pair);\n-    const {bid, ask} = await this.publicApi.getActualRates(pair);\n-\n-    this.pairs[pair].lastPrice = lastPrice;\n-    this.pairs[pair].buyRate = bid;\n-    this.pairs[pair].sellRate = ask;\n-\n-    const { minAmount, minCost } = await this.publicApi.getMarketInfo(pair);\n-    this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n-    this.pairs[pair].minAmount2 = minCost;\n-\n-    await this.pairRepository.save(\n-      this.pairs[pair]\n-    );\n-\n-    return this.pairs[pair];\n-  }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691636606738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,13 +67,13 @@\n \n     return this.pairs[pair];\n   }\n \n-  setInfo(pair, data) {\n-    updateModel(this.pairs[pair], data);\n+  async setInfo(pairModel, data) {\n+    updateModel(pairModel, data);\n     \n     await this.pairRepository.save(\n-      this.pairs[pair]\n+      pairModel\n     );\n   }\n \n   public async refreshPairInfo(currency1: string, currency2: string) {\n"
                },
                {
                    "date": 1691636665043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,105 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { checkLimits, elapsedSecondsFrom, lock, updateModel } from \"../helpers\";\n+import { PublicApiService } from \"./publicApi.service\";\n+import { InjectRepository } from \"@nestjs/typeorm\";\n+import { Pair } from \"./entities/pair.entity\";\n+import { Repository } from \"typeorm\";\n+\n+@Injectable()\n+export class PairService  {\n+\n+  pairs:{ [id: string]: Pair }={};\n+  lastRequestTime={};  \n+  FETCH_TIMEOUT;\n+  minAmount;\n+  minCost;\n+\n+  constructor(\n+    \n+    public publicApi: PublicApiService,\n+\n+    @InjectRepository(Pair)\n+    private pairRepository: Repository<Pair>\n+  ) {    \n+    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n+    \n+  }\n+\n+  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n+    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n+    if (!pair) {\n+      pair = this.pairRepository.create({currency1, currency2})\n+      await this.pairRepository.save(\n+        pair\n+      );\n+      const pairTitle = currency1 + '/' + currency2;\n+      this.lastRequestTime[pairTitle] = 1;\n+    }\n+    return pair;\n+  }\n+\n+  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n+\n+    const pair = currency1 + '/' + currency2;\n+    if (!this.pairs[pair]) {\n+      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n+    }\n+\n+    if (!this.lastRequestTime[pair]) {\n+      this.lastRequestTime[pair] = 1;\n+    }\n+\n+\n+    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n+\n+      await lock.acquire('requestLastPair ' + pair, async () => {\n+\n+        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n+          return this.pairs[pair];\n+        }\n+\n+        this.lastRequestTime[pair] = Date.now()/1000;\n+        await this.refreshPairInfo(currency1, currency2);\n+\n+      });\n+\n+    }\n+\n+    return this.pairs[pair];\n+  }\n+\n+  async setInfo(pairModel, data) {\n+    updateModel(pairModel, data);\n+    \n+    await this.pairRepository.save(\n+      pairModel\n+    );\n+  }\n+\n+  public async refreshPairInfo(currency1: string, currency2: string) {\n+    const pair = currency1 + '/' + currency2;\n+\n+    const lastPrice = await this.publicApi.getLastPrice(pair);\n+    const {bid, ask} = await this.publicApi.getActualRates(pair);\n+    const { minAmount, minCost, fee } = await this.publicApi.getMarketInfo(pair);\n+\n+    this.pairs[pair].lastPrice = lastPrice;\n+    this.pairs[pair].buyRate = bid;\n+    this.pairs[pair].sellRate = ask;    \n+    this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n+    this.pairs[pair].minAmount2 = minCost;\n+    this.pairs[pair].fee = fee;\n+\n+    updateModel(this.pairs[pair], {\n+      lastPrice,\n+      buyRate: bid,\n+      sellRate: ask,\n+      minAmount1: checkLimits(minAmount, minCost, ask),\n+      minAmount2: minCost,\n+      fee\n+    })\n+\n+    return this.pairs[pair];\n+  }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691636674993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,114 +89,17 @@\n     this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n     this.pairs[pair].minAmount2 = minCost;\n     this.pairs[pair].fee = fee;\n \n-    updateModel(this.pairs[pair], {\n+    await updateModel(this.pairs[pair], {\n       lastPrice,\n       buyRate: bid,\n       sellRate: ask,\n       minAmount1: checkLimits(minAmount, minCost, ask),\n       minAmount2: minCost,\n       fee\n-    })\n+    });\n \n     return this.pairs[pair];\n   }\n \n-}\n-import { Injectable } from \"@nestjs/common\";\n-import { checkLimits, elapsedSecondsFrom, lock, updateModel } from \"../helpers\";\n-import { PublicApiService } from \"./publicApi.service\";\n-import { InjectRepository } from \"@nestjs/typeorm\";\n-import { Pair } from \"./entities/pair.entity\";\n-import { Repository } from \"typeorm\";\n-\n-@Injectable()\n-export class PairService  {\n-\n-  pairs:{ [id: string]: Pair }={};\n-  lastRequestTime={};  \n-  FETCH_TIMEOUT;\n-  minAmount;\n-  minCost;\n-\n-  constructor(\n-    \n-    public publicApi: PublicApiService,\n-\n-    @InjectRepository(Pair)\n-    private pairRepository: Repository<Pair>\n-  ) {    \n-    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n-    \n-  }\n-\n-  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n-    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n-    if (!pair) {\n-      pair = this.pairRepository.create({currency1, currency2})\n-      await this.pairRepository.save(\n-        pair\n-      );\n-      const pairTitle = currency1 + '/' + currency2;\n-      this.lastRequestTime[pairTitle] = 1;\n-    }\n-    return pair;\n-  }\n-\n-  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n-\n-    const pair = currency1 + '/' + currency2;\n-    if (!this.pairs[pair]) {\n-      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n-    }\n-\n-    if (!this.lastRequestTime[pair]) {\n-      this.lastRequestTime[pair] = 1;\n-    }\n-\n-\n-    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n-\n-      await lock.acquire('requestLastPair ' + pair, async () => {\n-\n-        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n-          return this.pairs[pair];\n-        }\n-\n-        this.lastRequestTime[pair] = Date.now()/1000;\n-        await this.refreshPairInfo(currency1, currency2);\n-\n-      });\n-\n-    }\n-\n-    return this.pairs[pair];\n-  }\n-\n-  async setInfo(pairModel, data) {\n-    updateModel(pairModel, data);\n-    \n-    await this.pairRepository.save(\n-      pairModel\n-    );\n-  }\n-\n-  public async refreshPairInfo(currency1: string, currency2: string) {\n-    const pair = currency1 + '/' + currency2;\n-\n-    const lastPrice = await this.publicApi.getLastPrice(pair);\n-    const {bid, ask} = await this.publicApi.getActualRates(pair);\n-    const { minAmount, minCost, fee } = await this.publicApi.getMarketInfo(pair);\n-\n-    this.pairs[pair].lastPrice = lastPrice;\n-    this.pairs[pair].buyRate = bid;\n-    this.pairs[pair].sellRate = ask;    \n-    this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n-    this.pairs[pair].minAmount2 = minCost;\n-    this.pairs[pair].fee = fee;\n-\n-\n-    return this.pairs[pair];\n-  }\n-\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691636685346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,9 +89,9 @@\n     this.pairs[pair].minAmount1 = checkLimits(minAmount, minCost, ask);\n     this.pairs[pair].minAmount2 = minCost;\n     this.pairs[pair].fee = fee;\n \n-    await updateModel(this.pairs[pair], {\n+    await this.setInfo(this.pairs[pair], {\n       lastPrice,\n       buyRate: bid,\n       sellRate: ask,\n       minAmount1: checkLimits(minAmount, minCost, ask),\n"
                },
                {
                    "date": 1691636866564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,98 @@\n+import { Injectable } from \"@nestjs/common\";\n+import { checkLimits, elapsedSecondsFrom, lock, updateModel } from \"../helpers\";\n+import { PublicApiService } from \"./publicApi.service\";\n+import { InjectRepository } from \"@nestjs/typeorm\";\n+import { Pair } from \"./entities/pair.entity\";\n+import { Repository } from \"typeorm\";\n+\n+@Injectable()\n+export class PairService  {\n+\n+  pairs:{ [id: string]: Pair }={};\n+  lastRequestTime={};  \n+  FETCH_TIMEOUT;\n+  minAmount;\n+  minCost;\n+\n+  constructor(\n+    \n+    public publicApi: PublicApiService,\n+\n+    @InjectRepository(Pair)\n+    private pairRepository: Repository<Pair>\n+  ) {    \n+    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n+    \n+  }\n+\n+  public async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n+    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n+    if (!pair) {\n+      pair = this.pairRepository.create({currency1, currency2})\n+      await this.pairRepository.save(\n+        pair\n+      );\n+      const pairTitle = currency1 + '/' + currency2;\n+      this.lastRequestTime[pairTitle] = 1;\n+    }\n+    return pair;\n+  }\n+\n+  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n+\n+    const pair = currency1 + '/' + currency2;\n+    if (!this.pairs[pair]) {\n+      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n+    }\n+\n+    if (!this.lastRequestTime[pair]) {\n+      this.lastRequestTime[pair] = 1;\n+    }\n+\n+\n+    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n+\n+      await lock.acquire('requestLastPair ' + pair, async () => {\n+\n+        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n+          return this.pairs[pair];\n+        }\n+\n+        this.lastRequestTime[pair] = Date.now()/1000;\n+        await this.refreshPairInfo(currency1, currency2);\n+\n+      });\n+\n+    }\n+\n+    return this.pairs[pair];\n+  }\n+\n+  async setInfo(pairModel, data) {\n+    updateModel(pairModel, data);\n+    \n+    await this.pairRepository.save(\n+      pairModel\n+    );\n+  }\n+\n+  public async refreshPairInfo(currency1: string, currency2: string) {\n+    const pair = currency1 + '/' + currency2;\n+\n+    const lastPrice = await this.publicApi.getLastPrice(pair);\n+    const {bid, ask} = await this.publicApi.getActualRates(pair);\n+    const { minAmount, minCost, fee } = await this.publicApi.getMarketInfo(pair);\n+\n+    await this.setInfo(this.pairs[pair], {\n+      lastPrice,\n+      buyRate: bid,\n+      sellRate: ask,\n+      minAmount1: checkLimits(minAmount, minCost, ask),\n+      minAmount2: minCost,\n+      fee\n+    });\n+\n+    return this.pairs[pair];\n+  }\n+\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1691551883907,
            "name": "Commit-0",
            "content": "import { Injectable } from \"@nestjs/common\";\nimport { checkLimits, elapsedSecondsFrom, lock } from \"../helpers\";\nimport { PublicApiService } from \"./publicApi.service\";\nimport { InjectRepository } from \"@nestjs/typeorm\";\nimport { Pair } from \"./entities/pair.entity\";\nimport { Repository } from \"typeorm\";\n\n@Injectable()\nexport class PairService  {\n\n  pairs:{ [id: string]: Pair }={};\n  lastRequestTime={};  \n  FETCH_TIMEOUT;\n  minAmount;\n  minCost;\n\n  constructor(\n    public publicApi: PublicApiService,\n    @InjectRepository(Pair)\n    private pairRepository: Repository<Pair>\n  ) {    \n    this.FETCH_TIMEOUT = Number(process.env.EXCHANGE_RATES_FETCH_TIMEOUT);\n    ({ minAmount: this.minAmount, minCost: this.minCost } = await this.publicApi.getLimits(this.accountConfig(accountId).pair));\n  }\n\n  async fetchOrCreatePair(currency1: string, currency2: string): Promise<Pair> {\n    let pair = await this.pairRepository.findOneBy({currency1, currency2});\n    if (!pair) {\n      pair = this.pairRepository.create({currency1, currency2})\n      await this.pairRepository.save(\n        pair\n      );\n      const pairTitle = currency1 + '/' + currency2;\n      this.lastRequestTime[pairTitle] = 1;\n    }\n    return pair;\n  }\n\n  async getOrRefreshPair(currency1: string, currency2: string):Promise<Pair> {\n\n    const pair = currency1 + '/' + currency2;\n    if (!this.pairs[pair]) {\n      this.pairs[pair] = await this.fetchOrCreatePair(currency1, currency2);\n    }\n\n    if (!this.lastRequestTime[pair]) {\n      this.lastRequestTime[pair] = 1;\n    }\n\n\n    if ( elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair]) ) {\n\n      await lock.acquire('requestLastPair ' + pair, async () => {\n\n        if ( !elapsedSecondsFrom(this.FETCH_TIMEOUT, this.lastRequestTime[pair])) {\n          return this.pairs[pair];\n        }\n\n        this.lastRequestTime[pair] = Date.now()/1000;\n        await this.refreshPairInfo(currency1, currency2);\n\n      });\n\n    }\n\n    return this.pairs[pair];\n  }\n\n  public async refreshPairInfo(currency1: string, currency2: string) {\n    const pair = currency1 + '/' + currency2;\n\n    const lastPrice = await this.publicApi.getLastPrice(pair);\n    const {bid, ask} = await this.publicApi.getActualRates(pair);\n\n    this.pairs[pair].lastPrice = lastPrice;\n    this.pairs[pair].buyRate = bid;\n    this.pairs[pair].sellRate = ask;\n\n    const amount1: number = checkLimits(ask);\n\n    await this.pairRepository.save(\n      this.pairs[pair]\n    );\n\n    return this.pairs[pair];\n  }\n\n}"
        }
    ]
}